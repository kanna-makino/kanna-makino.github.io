<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[失恋后的七夕]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%A4%B1%E6%81%8B%E5%90%8E%E7%9A%84%E4%B8%83%E5%A4%95%2F</url>
    <content type="text"><![CDATA[对于各种各样的“节日”，独来独往的我向来是不太关心的。一方面不太能理解现代人的新式思维，另一方面觉得跟自己毫不相关。从双十一、520、情人节再到女生节、七夕节，人们表达爱意的方式变得简单而直接。从工作以来，虽然依旧毫不关心，但是每逢此类节日，总是能早早的就能从同事们对于礼物的讨论中知道再过几天什么日子又要到了。 或许我的性格决定了我本就不适合和其他人一起生活，所以直到现在，也没有过感情经历；并且在能看见的将来，也没有抱有任何的希望。 这么多年，终于遇到一个动心的人，结果也是有缘无分，落花有意流水无情。虽然喜欢的女生最终陪在了别人的身旁让我万念俱灰，但是事后细细想来，或许这才是最好的结果呢？跟我在一起她能得到幸福吗？显然，至少我的答案不是肯定的。如果在我身边得不到快乐，那她现在的选择不正好就是我的选择吗，那我还有什么可耿耿于怀的呢？ 失去一个喜欢的人，原来是一件如此痛心的事。我懂得了为什么有这么多人为了爱情要死要活，不能和喜欢的人在一起，那活着也确实不会有什么乐趣，况且生活本来就很苦了。 可惜人终究不能控制自己的爱恨喜恶，所以每个人都会经历喜欢的人喜欢着别人这种无能为力的事情。罢了，学着去原谅吧，相识一场，好聚好散。 时间短暂，街头小巷、音容笑貌，终究是留下了些许的回忆，暂且当成最后的纪念。 很多年没遇到过这么沉重的打击了，每天早上醒来，仍然会不自觉的一阵心痛。不过打击越是沉重，才越能让人学会点什么。我曾不停的假如、不停的假如，假如早点把自己感情说出口，假如……即便假设一万次，也是于事无补了，过去的不会再重来。“不要等到失去了才懂得珍惜”这种世人皆知的陈词滥调，竟然也只有真的失去了才能懂得其中的道理。经历了这件事，我才切身体会到其中的含义，希望以后不会再犯同样的错误吧。 今天你和谁甜言蜜语？ 今天你和谁亲密无间？ …… 距离出差还剩下三天时间，离开你生活的城市，是否能更快的忘记你呢？我不得而知，我希望这次也能和在别的事情上一样健忘。 最近的情绪更加低落了，出差之后，又是一个完全陌生的环境，不知道会是什么样的心境，只希望，能早日抹去有你的回忆，走出你的背影。]]></content>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影-《月球》]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%94%B5%E5%BD%B1-%E3%80%8A%E6%9C%88%E7%90%83%E3%80%8B%2F</url>
    <content type="text"><![CDATA[不知道为什么，想在 MacOS 上恢复以前的 Hexo 博客，但是安装 Hexo 的时候总是报错，安装不成功。只能等出差之后有时间了再去想办法恢复了。Hexo 维护起来还是有点困难，尤其是在原博客的基础上加了各种插件之后，再加上国内的局域网环境，恢复起来更是费劲。 因为恢复 Hexo 博客暂时有困难，所以就先把博客放在 Blogger 上吧。 –刚才网上查了下，五分钟不到恢复了… 今天晚上回来，没什么事可做，就看了部电影打发时间。我一向喜欢看科幻片，但是比较知名的科幻片基本都看一遍了，类似于《火星救援》、《回到未来》之类的。 出于之前对月球各种现象的好奇，就从网上找了《月球》（迅雷下载地址：ed2k://|file|【电影家园www.idyjy.com下载】月球BD国英双语双字.mkv|2217685691|B8C4591F5409AD0D6BA1A6BE485FAAF4|h=FAAI4HCQIMWBHLOWJXRCQLJFXKKUIO6L|/）来看。其实看了前五六分钟才发现，以前看过，但是剧情已经全然忘记了，正好也不知道要看什么，就接着看下去了。 mkv 格式的视频直接用 VLC 和QuickTime 还不能直接播放，没有对应的解码器，安装了 IINA 就好了。 简单而有一波三折的剧情，固定的拍摄场景，还是很能吸引人。 月球旷工 Sam 与公司签订合同之后到了月球采矿，即将合同期满，返回地球与妻女团聚的时候，糟糕的精神状态让他遭遇了一起事故。事故之后从医护室醒来丧失了部分记忆，并设法离开基地前往事故地点，在事故月球车里发现了另一个自己，原来自己是从本体克隆而来。两个克隆 Sam 逐渐发现了基地中的所有秘密，两人设法赶在公司的“救援小组”到达之前利用氦传送器将干满三年的自己送回地球，但是身体状况急剧恶化的自己明白自己的生命即将终结，放弃了返回地球的机会，将机会让给了另一个健康的自己。合同期快满的 Sam 临死前通过卫星信号拨通了家里的电话，得知妻子已经去世，女儿已经 15 岁，内心无比痛苦。最终为了完成计划死在了出事故的月球车中，而新克隆的 Sam 则顺利的回到地球并将公司的恶行公布于世。 我喜欢这种简单不烧脑却又引人入胜的故事情节，而其中的关于人性、伦理、克隆技术以及人工智能的讨论更是给人以思考。 不过我印象更为深刻的是，Sam 在一个完全寂静、与世隔绝的环境中的生活状态。我自认为是一个孤独体质的人，从来不认为自己跟某个人或者某些人很亲近，并且对不认识的人更是保持着礼貌的距离。孤独，确实能改变一个人。三年的孤寂将 Sam 的正面性格全面摧毁，我甚至在想我现在的性格状态就是与世隔绝三年之后的 Sam 的生活状态吗？确实有很多相似的地方。但是他是幸福的，因为他知道虽然离家万里，但是在遥远的地球上有着深爱他的妻女，即便与世隔绝，生活始终还是有期待的，期待着回家、期待着与相爱的人团聚。而我呢？希望自己能早日走出这种状态吧。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 mjpg-streamer 的树莓派视频监控]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%9F%BA%E4%BA%8E-mjpg-streamer-%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[基于mjpg-streamer的视频监控视频监控搭建本来想用 python 来做的，但是 VLC 串流不知道是不是设置的问题，视频采集是正常的，但是接收端接收到的视频一团糊，在无意间知道了 mjpg-streamer 这个项目，GitHub 地址：https://github.com/jacksonliam/mjpg-streamer。 安装方法参照GitHub： 1234567sudo apt-get install cmake libjpeg8-devsudo apt-get install gcc g++cd mjpg-streamer-experimentalmakesudo make install 安装完之后就可以直接启动了： 1./mjpg_streamer -o "output_http.so -w ./www" -i "input_raspicam.so" 默认使用8080端口，浏览器打开地址： 1http://192.168.0.103:8080/?action=stream 就能实时查看树莓派摄像头采集到的视频。 外网访问在局域网内，直接访问树莓派的 ip 地址就能查看视频，但是如果想从外网访问的话，还需要做点手脚。 使用 frp 反向隧道进行内网穿透。 先分别在vps 和树莓派上安装frp 服务： 1wget https://github.com/fatedier/frp/releases/download/v0.20.0/frp_0.20.0_linux_amd64.tar.gz 解压上面下载的文件。 服务器端配置文件： 12345678进去目录vi frps.ini[common]bind_port = 7000 # frp与客户端绑定进行通信的端口auto_token = frp7vhost_http_port = 9000 # http 访问端口 树莓派配置文件： 12345678910111213141516171.进去目录2.vi frpc.ini[common]server_addr = 云服务器的IP # frps所在的服务器的 IPserver_port = 7000 # frp与服务器绑定进行通信的端口[ssh]type = tcplocal_ip = 192.168.0.103 # Pi所在局域网IPlocal_port = 22 # 本地端口remote_port = 6000 # ssh远程访问端口[web]type = httplocal_port = 8080 # web 服务对应的端口——mjpg-streamer所需端口custom_domains = 云服务器IP # frps所在的服务器的 IP 依次启动服务器端的 frp，树莓派视频采集，树莓派端 frp。 12345./frps -c ./frps.ini./mjpg_streamer -o "output_http.so -w ./www" -i "input_raspicam.so"./frpc -c ./frpc.ini 然后打开浏览器访问：http://xxx.xxx.xxx.xxx:9000/stream.html ，不知道是不是因为 VPS 在国外的原因，延迟有3 s 这样子。。 注意：树莓派只能运行 arm 架构的 frp（树莓派frp）。 参考： 基于树莓派+mjpg+frp+阿里云服务器的远程监控 树莓派上MJPG-streamer安装手顺]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作一年的Java程序员应该会什么？]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E7%9A%84Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E4%BC%9A%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[工作一年的Java程序员应该会什么？ 从5月27日开始计算，今天是测试第14天，每天打开页面点点点，截图贴数据，你努力贴图证明自己没有伪造数据的样子真的很可怜，你因为该用红色框而你却所用了蓝色而被要求从头到尾改一遍，因为两张图不太连贯而被要求重新测一遍的样子真可怜。当然了，这里的“你”就是我，一个在对日外包公司工作的我，也是和我一起贴图的同事们。 昨天下午改了一下午，今天早上改了一上午。我已经忍无可忍，但是我努力告诉自己要冷静，事实是我也做到了冷静，心态平和的修改evidence和重新做evidence。 下午五点钟，旁边review的其他公司外派过来的同事让我把evidence的数据改一改。这是一个测试数据库里insert_user和update_user有没有如期更新的case，她让我将操作前数据的insert_user改成和操作后的数据一致，我就说了我的想法，前后一致的话就看不出来到底有没有被更新了，我稍微解释了一下，我没有和她辩论或者想说服她的意思，我只是阐述了我的想法，我就说了一句“请告诉我我该做什么？”，然后她好像生气了。我也没再多说，直接重新测试。 可能因为这两天review我的evidence有很多需要改的地方她也不太高兴，而我三个星期以来因为测试积压在心里的情绪也朝着大脑汹涌而来，我目不转睛地盯着那为了测试而调整分辨率后变得模糊不清的21寸廉价惠普瞎眼屏幕，手里拿着不知道因为多少人握过而变得光滑发亮的垃圾鼠标，我的大脑里只有两个字：离职。 一转眼，入职已经一年了。前两天，公司还在热火朝天搞评价，公司对你的评价，leader对你的评价，我真希望，以后能增加一个员工对公司的评价。我是达到了公司的预期，可是公司达到了我的预期吗？答案是令人遗憾的，其实在入职之前我就知道结果不会令人太满意，但是却没想到会这么不满意。 每隔一段时间我就会问自己：从入职到今天，我写了几行代码？答案让我感到难堪。也是这段经历，让我知道，不是所有做软件的人都是技术大牛，工作经验十年，照样有人不知道public、private的含义和用途；工作七年、仍然有人不知道Github是什么，不知道vpn是什么；入职两年，不知道怎么新建一个Java类。只能说大千世界，无奇不有。 我没记错的话，软件工程里说过测试的目的是尽可能多的找出程序缺陷，而不是验证程序的正确性。我能理解也愿意遵守为了更好的协作和保证产品质量而订下的条条框框，但是如果一个公司将过多的精力放在表面工作、过分执着于线条尺寸和颜色、截图大小和位置上，伪造数据以满足case预期，而不去关心程序本身性能和运行状况的话，不去思考如何提高员工技术能力的话，那它是不会有什么长远发展的。 逛了两天v2ex，大家每天都能在工作中提高自己的技术能力，增加新的见闻，而我，不过是日复一日的截图再截图，对当前的处境感到万分焦虑，每天再听听同事们不停的 瓦您古、饿拉、努鲁、佛玛托，心态更是崩溃。每天即使没事，也要为了团队和谐在工位上坐到九点半，真的该死。 因为工作中几乎没有需要写代码的地方，身边同事的技术能力也是不敢恭维，没有技术氛围，办公室话题永远是吃。 以前还想着在这个城市有以两个熟悉的人，可以待一段时间，目前看来，也没有什么值得留恋的了。还是尽快开始找工作，希望离开这个地方吧。 墙内还想丝毫没有香港游行的消息。想起Twitter上的一个问题：二十年来，是中国变得像香港了还是香港变得像中国了？真为圈养的中国人感到悲哀。如果有来生，千万别再投胎到中国了，做中国人真累。倒行逆施，开历史的倒车，终将被钉在历史的耻辱柱上。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给树莓派安装Ubuntu MATE系统]]></title>
    <url>%2F2019%2F06%2F11%2F%E7%BB%99%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85Ubuntu-MATE%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[给树莓派安装Ubantu MATE操作系统 由于平时用的是Ubuntu系统，对这个系统比较熟悉，也想给树莓派也装这个系统，Linux下做SD卡启动盘网上资料比较少，担心发生对笔记本磁盘的误操作，最后在官网上找到了教程。 下载系统Ubuntu MATE for the Raspberry Pi Model B 2, 3 and 3+ 安装工具并写入系统123sudo apt-get install gddrescue xz-utilsunxz --verbose ubuntu-mate-18.04.2-beta1-desktop-armhf+raspi-ext4.img.xzsudo ddrescue -D --force ubuntu-mate-18.04.2-beta1-desktop-armhf+raspi-ext4.img /dev/sdx /dev/sda代表笔记本的磁盘，SD卡的盘符一般/dev/sdb1。 显示屏无反应网上说可能是 config.txt 设置问题，和显示器的分辨率之类的有关，但是写入了镜像之后再将SD卡插入到PC，已经无法挂载，报错： 12sudo mount /dev/sdb1 /mnt/sdb1mount: /mnt/sdb1: wrong fs type, bad option, bad superblock on /dev/sdb1, missing codepage or helper program, or other error. 问题排查进不去SD卡，挂载错误，说是文件类型错误。 安装工具： sudo apt-get install nfs-common 仍然是无法读取。 先安装 gnome-disk-utility ，在终端执行 ./gnome-disk-utility ，选择 Restore Image... ，写入镜像。 写完之后，退出SD卡。 将写入镜像的SD卡插入树莓派，连接显示器，接通电源，成功进入系统引导界面，清新的绿色界面。]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再记Hexo博客恢复]]></title>
    <url>%2F2019%2F06%2F09%2F%E5%86%8D%E8%AE%B0Hexo%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[Hexo博客恢复 从官网下载 Nodejs 二进制 文件（.tar.xz），解压到 /opt 目录下，添加连接： sudo tar -xvf xxxx.tar.xz sudo ln -s /opt/node-linux-x64xxxx/bin/node /usr/local/bin/node sudo ln -s /opt/node..../bin/npm /usr/local/bin/npm 然后进入博客文件夹，执行 sudo npm install 即可完成恢复。 折腾了半天一直各种报错，没想到这么简单。。]]></content>
      <categories>
        <category>Hexo博客维护</category>
      </categories>
      <tags>
        <tag>Hexo博客维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酸酸乳搭建小记]]></title>
    <url>%2F2019%2F06%2F09%2F%E9%85%B8%E9%85%B8%E4%B9%B3%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[酸酸乳搭建过程小记 ss现在算是完全被识别了，去年11月在同事的推荐下用了 云影vpn ，一个月3美元，15G流量，对于平时上上Twitter，stackoverflow来说，完全足够了，每月都能剩下一半多流量。但是想着自己一边花钱用着慢速网，自己的国外vps却闲着没事干，还是利用以下吧，节约资源。 客户端：首先，下载脚本到 /usr/local/ssr ： 1sudo git clone https://github.com/ssrbackup/shadowsocksr /usr/local/ssr 然后执行命令： 1cd /usr/local/ssr &amp;&amp; ./initcfg.sh 会看到生成了一个配置文件 user-config.json ，你可以将它复制到 /etc/ssr-config.json 修改配置文件 sudo vi /etc/ssr-config.json 大致前面几项需要配置一下： 123456789101112&quot;server&quot;: &quot;******&quot;, // 代理服务地址&quot;server_ipv6&quot;: &quot;::&quot;,&quot;server_port&quot;: 11873, // 端口号&quot;local_address&quot;: &quot;127.0.0.1&quot;, //本地socks5监听地址 &quot;local_port&quot;: 1080,//本地socks5代理端口&quot;password&quot;: &quot;xxxxxx&quot;, //密码&quot;method&quot;: &quot;rc4-md5&quot;,//加密方式&quot;protocol&quot;: &quot;xxxxx&quot;,//协议&quot;protocol_param&quot;: &quot;xxxxxx&quot;,//协议参数&quot;obfs&quot;: &quot;xxxxxx&quot;,//混淆方式&quot;obfs_param&quot;: &quot;xxxxxxxx&quot;,//混淆参数 执行命令启动客户端： sudo python shadowsocks/local.py -c /etc/ssr-config.json 启动成功后，按 ctrl + z 切换出来，再用 jobs 查看任务编号，使用 bg %编号 后台运行； 可以通过 jobs 看到后台任务，可以通过 fg %编号 切换进去。 服务端执行下面的命令获取脚本： 1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; sudo bash ssr.sh 依照提示完成服务端各个参数的配置即可监听服务。 Enjoy it ! 之前搭建的ss才用了不到三天，连服务器ip都被和谐了，ssr用了一两个星期还健在，应该能支撑一段时间吧。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>酸酸乳</tag>
        <tag>vpn</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-26周记]]></title>
    <url>%2F2019%2F05%2F27%2F05-26%E5%91%A8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[忙碌的一周 加班还在继续。尽管每天多上3个小时的班，但是一周仿佛还是一样的短，周一到周末也就是一眨眼间。 冬天里穿单衣，夏天里披外套。大概是因为公司的空调温度太低，周三周四有点感冒发烧的症状，上班的时候头疼而且眼睛也特别不舒服，好在早早的睡了两天之后又恢复了正常。意外的进了这个项目打断了原本才开始几天的锻炼计划，照现在情况看，大概是要到9月份去了，想想都还要远着呢，不知道哪天是个头。 似乎这两年什么事情都不顺利，总是事与愿违。在学校每天努力学习，成绩却徘徊在中等；最讨厌外包，最终却做了外包；最不想做测试，偏偏公司只有测试；想工资高点，却偏偏一个月3500。 明明每天不停地学习，从语言到框架，书买了一大堆。却最终还是和 public, protected, private 都没搞明白的five们拿着分毫不差的工资。我是一个想做第一也愿意付出努力的人，但是始终没有找到这其中的原因。总之，先做到年底，然后离开这个公司吧。 想着从明天开始又是连续三周的测试，真的很头疼，我宁愿写五天代码，也不想做一天测试。 上周周四一下收到三封离职邮件，都是工作了5年多的人。我也想过，如果自己在这里工作5年，5年后我会是什么样？不敢想象，估计在技术上和一个用心学过技术的应届生应该不会有太大的差别。据我的观察，公司真正懂点技术的人也就三五个，其他有点工作经验人的八成都是five。 又是忙碌的周末。周六学妹来我这里写了一下午一晚上的代码。有个人陪在身边确实是很好的感觉。而且她也是懂些东西的人，从她那里学到不少新的东西。 晚上一起出去吃了饭，回来写代码差不多到10点才送她回的学校，希望她7月份入职后能像她说的那样住得近一些。 帮她做了OpenOffice的转换，pdf文件转换，今天又忙了一天，还差弹窗显示这个功能了。看了腾讯微云是弹窗，还得仔细研究研究。 晚上还给一个大四的老乡解决了 项目名更改重新发布，更改数据库名 的问题，唉，总感觉她的思路很怪，页面打不开为什么不去找页面为什么打不开而是打开微信跟别人说页面打不开，遇到问题不会去思考解决问题的办法，明明数据库连接就这么几行代码，自己不去仔细读相关代码，而是打开微信提问，提问吧还不说起因经过和现场，就一句“页面打不开”…罢了罢了。 昨天晚上送学妹回学校以后在不经意间发现B站竟然买下了《轻音少女》的版权，而且第一季第二季和剧场版都买了，真的很开心，我突然想让陈睿他🐎复活了。但是还是要充会员才能看，充钱是不可能充钱的了，这辈子也不可能给Bilibili矿业充钱的。 累了，思维有点混乱了，玩玩手机睡觉吧。 一个周末就过去了。 房间里又只剩下了键盘的响声。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在JavaScript中踩过的坑]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%88%91%E5%9C%A8JavaScript%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[我在Javascript中踩过的坑！ 前言时至今日也没有系统深入的学习过JavaScript，虽然常用，但是也只停留在最基础的使用上。没有系统深入的了解，必然要踩一些前端众所周知，却让小白绞尽脑汁地大坑！ 今天又在坑里摸了一天，记录一下，权当是写日记了。 最近连续加班，确实有些身心俱疲；加上昨天下午的“午后小睡”导致晚上失眠，到快四点钟才睡着，今天早上快十点钟还躺在床上。 需求正在逛Twitter，做毕设地学妹给我提了两个需求： 登陆页面的表单检验； 注册页面的重复用户名检测。 问题：从Ajax中返回值用JQuery.validate插件给登陆表单加了校验，挺简单，同样的方法给注册界面加个校验，唯一不同的是需要使用ajax从后台请求到用户名是否已经存在，也挺简单。 于是乎，有了下面这段代码： 12345678910111213141516171819202122// do something$.validator.addMethod("checkUniqueUsername", function(value, element, params) &#123; return this.optional(element) || checkUniqueUsername(value);&#125;, "用户名已被占用！");function checkUniqueUsername(username) &#123; if (username !== null &amp;&amp; username !== undefined &amp;&amp; username !== '') &#123; var data = &#123;'loginname': username&#125;; $.ajax(&#123; type: 'post', url: '/checkloginname', data: JSON.stringify(data), dataType: 'json', contentType: 'application/json', success: function (res) &#123; return (parseInt(res.tip) === 0); &#125; &#125;); &#125; else &#123; return false; &#125;&#125; 三五分钟，就写完了代码，跑一跑测一下准备验收了。诡异的事情出现了，checkUniqueUsername()总是返回false。 Ajax中return的结果没事，静下心来慢慢调，就这几行代码，怎么说也要给你调得明明白白的。调试后发现parseInt(res.tip)===0是true，可是return 之后函数的返回值是false，这没道理啊！ 网上查了一下，原来是在ajax中直接return并不是return到外层函数中，不深究，改个写法，于是有了v2版本： 123456789101112131415161718192021222324// do something$.validator.addMethod("checkUniqueUsername", function(value, element, params) &#123; return this.optional(element) || checkUniqueUsername(value);&#125;, "用户名已被占用！");function checkUniqueUsername(username) &#123; if (username !== null &amp;&amp; username !== undefined &amp;&amp; username !== '') &#123; var result = false; var data = &#123;'loginname': username&#125;; $.ajax(&#123; type: 'post', url: '/checkloginname', data: JSON.stringify(data), dataType: 'json', contentType: 'application/json', success: function (res) &#123; result = (parseInt(res.tip) === 0); &#125; &#125;); return result; &#125; else &#123; return false; &#125;&#125; 检查了一下，再也想不出还能有什么问题了，那就跑一下吧。诡异的结果又出现了，函数返回值依旧是false，心态崩了，这就好比 var count = 1; console.log(count);却输出了2一样，难以置信！ Ajax同步和异步查了半天，终于看到一个答案：ajax的同步和异步。可谓是一语惊醒梦中人，我责备自己为什么调试了这么久，却没有想到这个方向，而且同步异步的坑已经不是第一次踩了。v3版本终于解决了这个问题，失之毫厘，差之千里。 12345678910111213141516171819202122232425// do something$.validator.addMethod("checkUniqueUsername", function(value, element, params) &#123; return this.optional(element) || checkUniqueUsername(value);&#125;, "用户名已被占用！");function checkUniqueUsername(username) &#123; if (username !== null &amp;&amp; username !== undefined &amp;&amp; username !== '') &#123; var result = false; var data = &#123;'loginname': username&#125;; $.ajax(&#123; type: 'post', url: '/checkloginname', data: JSON.stringify(data), dataType: 'json', contentType: 'application/json', async: false, success: function (res) &#123; result = (parseInt(res.tip) === 0); &#125; &#125;); return result; &#125; else &#123; return false; &#125;&#125; 但是每次运行控制台都会出现JQuery的提示：使用同步会降低用户体验，总归是有个解决办法，有时间再深究一下吧。 JavaScript浮点运算今天的经历让我回想起了去年遇到的一个JavaScript的问题，当时在做一个现金流管理系统，遇到一个需求是根据固定利息和浮动利息自动计算出最终利息，随便输了几组数据测试，没有出现异样，但是最后一组数据的时候出现了诡异的结果！4.1 + 4.3 = 8.399999999999999，这真是见了鬼了。。很久之前学过的知识这分钟哪里回想得起来。上网查了才发现原来是JavaScript的设计缺陷导致的问题，也都提出了几种解决方案。 后话平时用Java习惯了，思维方式有些不灵活，从对Python的理解中也能看出来。 总之，遇到问题，要发散思维，尽量快速的去确定调查的方向，最终尽快的解决问题。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>Exp</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解简单例子]]></title>
    <url>%2F2019%2F05%2F15%2FJava%E6%B3%A8%E8%A7%A3%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[了解Java注解（@Annotation） 前言 为什么突然想起来注解呢？今天上午同事遇到一个和注解相关的问题，JSP页面传值到后台后（其实前后端并不分离），但是在POJO类上的校验注解值不满足的条件下也通过了，让我给帮忙看看。因为其他组的同事相同的通用代码并没有这个问题，而且对注解的处理是封装在框架中的，所以一开始便排除了问题在后台思路，转向页面传值去调查。虽然最后找到原因是因为没有清空Eclipse的.class文件重新编译，但是感觉已经对之前学过的注解部分的知识生疏了。刚好今天没加班，就赶紧复习一下。 本想在网上找两篇文章回忆一下，但是好像例子写得都不完整。刚好前段时间刚买了一本《Java编程思想》，就赶紧翻开看了一下，一直记得书里给出的例子也是数据库字段注解相关的。 相关概念及原理参见 ==&gt; 《Java编程思想》第二十章&lt;注解&gt;。 四个元注解： @Target @Retention @Document Inherited 注解主要是用户按自己的需求来实现。 一个简单的例子先创建两个注解，@Digits和@NotEmpty，用来注解属性是否满足给定条件。 代码如下： 1234567891011121314151617181920212223package com.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * &lt;p&gt; * 标注一个字段只能为数字，且最大长度为maxLength，最大小数位为fraction * 默认没有小数位 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:42 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Digits &#123; public int maxLength(); public int fraction() default 0;&#125; 12345678910111213141516171819package com.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * &lt;p&gt; * 标注一个字段不能为空 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:47 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface NotEmpty &#123;&#125; 定义一个处理类处理自定义注解：（主要利用反射机制） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.Annotation;import java.lang.annotation.Annotation;import java.lang.reflect.Field;/** * &lt;p&gt; * 处理自定义注解 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:59 */public class AnnotationProcesser &#123; public void process(Table table) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException &#123; Class clazz = table.getClass(); if (clazz == null) &#123; throw new ClassNotFoundException("class not found!"); &#125; Field[] fields = clazz.getDeclaredFields(); String fieldName; for (Field field : fields) &#123; System.out.println("--------------------------"); field.setAccessible(true); Annotation[] annotations = field.getDeclaredAnnotations(); fieldName = field.getName(); System.out.println("--&gt; info: into " + fieldName); for (Annotation annotation : annotations) &#123; System.out.println("--&gt; info: " + annotation.annotationType()); if (annotation instanceof Digits) &#123; System.out.println("--&gt; info: get @Digits annotation on " + fieldName); int maxLength = ((Digits) annotation).maxLength(); int annotatedFraction = ((Digits) annotation).fraction(); String[] fraction = String.valueOf(table.getCount()).split("\\."); if (String.valueOf(table.getCount()).length() &gt; maxLength) &#123; System.out.println("--&gt; error: maxLength exceed!"); &#125; if (fraction.length &gt; 1 &amp;&amp; fraction[1].length() &gt; annotatedFraction) &#123; System.out.println("--&gt; error：fraction length exceed!"); &#125; else &#123; System.out.println("--&gt; info: " + fieldName + " validate success!"); &#125; &#125; else if (annotation instanceof NotEmpty) &#123; System.out.println("--&gt; info: get @NotEmpty annotation on " + fieldName); if (table.getDescription() == null || "".equals(table.getDescription())) &#123; System.out.println("--&gt; error: empty is not allowed!"); &#125; else &#123; System.out.println("--&gt; info: " + fieldName + " validate success!"); &#125; &#125; &#125; &#125; &#125;&#125; 主测试类：（省略getter和setter） 12345678910111213141516171819202122232425262728293031323334353637package com.Annotation;/** * &lt;p&gt; * 自定义注解测试类 * &lt;/p&gt; * * @author zhulongkun20@163.com * @since 2019-05-14 21:49 */public class Table &#123; @Digits(maxLength = 6, fraction = 2) private double count; @NotEmpty private String description; public Table(double count, String description) &#123; this.count = count; this.description = description; &#125; public static void main(String[] args) throws IllegalAccessException, ClassNotFoundException, NoSuchFieldException &#123; Table testTable1 = new Table(1234567, "description1"); Table testTable2 = new Table(12.001, "description2"); Table testTable3 = new Table(123.01, "description3"); Table testTable4 = new Table(123.01, null); Table testTable5 = new Table(123.01, "description5"); AnnotationProcesser processer = new AnnotationProcesser(); processer.process(testTable1); processer.process(testTable2); processer.process(testTable3); processer.process(testTable4); processer.process(testTable5); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从两次毕设题目和要求说说我的感受]]></title>
    <url>%2F2019%2F05%2F12%2F%E4%BB%8E%E4%B8%A4%E6%AC%A1%E6%AF%95%E8%AE%BE%E9%A2%98%E7%9B%AE%E5%92%8C%E8%A6%81%E6%B1%82%E8%AF%B4%E8%AF%B4%E6%88%91%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[从两次毕设的题目要求和代码经历说说我的感受 近况这阵子很忙。 好久没有静下心来随便写点什么了。 这个想法在第一次毕设，也就是去年我做自己的毕设时还不是很强烈。今年3月底，应一个想赚点外快的同事的邀请，帮一个北京科技大学的大四学生做了一个毕业设计，到今天，差不多是两个月过去了，终于完成了所有的代码。 去年虽然也是三月底开始五月初完成，但是那时候对很多东西都不熟悉，基本是一步一个坑，今年好多了，轻车熟路，除了遇到几个之前没遇到过的坑之外，一切都还顺利，感触最深的应该还是碰上连续加班，每天十点钟才到家，随便写几行就十二点多，一段时间下来，感觉有点承受不住。 代码体会另外一点就是虽说两个人在写代码，但实际上只有我一个人。一万多行的代码，同事只有3次提交，1300行代码，还全是pojo类和xml映射文件，更不用说遇到很多问题时都是我一个人在找解决办法。 不论做什么事，能遇上有责任心的合作者真的是一件很值得庆幸的事情，且不说技术怎么样，光是态度好这一点就能给人很大的鼓舞。想起去年一起在实训基地做毕设室友，既要忙着做毕设，又要忙着做实习的项目，不懂的东西也很多，一个人每天焦头烂额，就算是在这种情况下，他的七八个队友竟然在实习项目答辩的前一天也没有人问问我能帮忙做点什么，进度怎么样，竟然还有一个班上的女生说了一句：这个项目答辩完了我要拿去当作我的毕设。我们两人当时只觉得震惊，只觉得真是大千世界，无奇不有。我一个旁人看了都觉得很过意不去，也无法理解他们是怎么做到心安理得的。说到这里，想起前两天晚上加班和同事一起打车回住处（出租屋），在车上他向司机暗示，西安的出租车可以随便打发票，他的朋友晚上从机场打车到住处，两个人本来只需要叫一个车，但是为了在报销的时候多报150块钱，所以两人分别打了一个车，司机表示他们也可以随便打任意时间任意地点的发票。我听了很是有感触，我只说出了我内心的想法：这样做不会觉得于心不安吗？这样的事情听说越多或是知道越多，可能我会更加频繁的反思自己的为人处世方式，但是再怎么反思，我想自己也绝不能做出类似的事情，正直，是一个人最基本的品德，这一点，应该永远坚持。 脑残毕设题目和需求说说毕设题目吧，“学生管理系统”，我想第一次在毕业设计中出现这个题目可以追溯到十年前，每年全国有多少个同样的毕设题目呢？这十来年下来，加上平时的大作业各种场合出现的题目，同题目的毕业论文大概都成千上万了。虽说这个题目很经典，但是我想出题老师还是有发散一下思维的余地，每年都搬出上年那连需求都没提几个字的毕设题目，扪心自问一下，对得起每个月工资卡里那些钱吗？还需要自己根据题目去编需求，真的不想说什么了。 不要抱怨 继续写吗？可以写，但没必要。 学了四年软件工程， 不会写SQL怎么了？ 不会连数据库怎么了？ 不懂得编程规约怎么了？ 发代码和文字用图片发怎么了？ 张口就问不懂提问的艺术怎么了？ 贴报错异常信息用手机拍控制台发送怎么了？ 问题解决不说谢谢一声不响有新问题直接“在吗”怎么了？ 垃圾就垃圾呗，我能改变什么吗？不能。 既然不能改变，就请不要抱怨。 垃圾就垃圾吧，还是想想自己下个月房租怎么办比较实际。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax返回error可能原因分析]]></title>
    <url>%2F2019%2F05%2F12%2Fajax%E8%BF%94%E5%9B%9Eerror%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ajax总是进入error的可能原因 后台返回： 1Successfully completed request 前端ajax总是执行error部分的代码。 原因： 后台只返回了 “success” 字符串，不是规范的json格式，所以没有执行预期逻辑。 最好在后台返回 严格规范 的json防止此类错误。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用Swagger2构建强大的RESTful API文档]]></title>
    <url>%2F2019%2F04%2F29%2FSpring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8Swagger2%E6%9E%84%E5%BB%BA%E5%BC%BA%E5%A4%A7%E7%9A%84RESTful-API%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot中使用Swagger2构建强大的RESTful API文档 由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。 这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题： 由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。 随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。 为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示： 下面来具体介绍，如果在Spring Boot中使用Swagger2。首先，我们需要一个Spring Boot实现的RESTful API工程，若您没有做过这类内容，建议先阅读Spring Boot构建一个较为复杂的RESTful APIs和单元测试。 下面的内容我们会以教程样例中的Chapter3-1-1进行下面的实验（Chpater3-1-5是我们的结果工程，亦可参考）。 添加Swagger2依赖在pom.xml中加入Swagger2的依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger2。 12345678910111213141516171819202122232425@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.didispace.web")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIs") .description("更多Spring Boot相关文章请关注：http://blog.didispace.com/") .termsOfServiceUrl("http://blog.didispace.com/") .contact("程序猿DD") .version("1.0") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。 再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。 添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@RestController@RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value="获取用户列表", notes="") @RequestMapping(value=&#123;""&#125;, method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @ApiOperation(value="创建用户", notes="根据User对象创建用户") @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") @RequestMapping(value="", method=RequestMethod.POST) public String postUser(@RequestBody User user) &#123; users.put(user.getId(), user); return "success"; &#125; @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value="更新用户详细信息", notes="根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long"), @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") &#125;) @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody User user) &#123; User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @ApiOperation(value="删除用户", notes="根据url的id来指定删除对象") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return "success"; &#125;&#125; 完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。 [ API文档访问与调试在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方“Try it out！”按钮，即可完成了一次请求调用！ 此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。 相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。 代码示例本文的相关例子可以查看下面仓库中的chapter3-1-5目录： Github：https://github.com/dyc87112/SpringBoot-Learning Gitee：https://gitee.com/didispace/SpringBoot-Learning 如果您觉得本文不错，欢迎Star支持，您的关注是我坚持的动力！ 参考信息 Swagger官方网站 无作者本人授权请勿转载。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>swagger</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Tomcat 8005端口Cannot assign requested address的经历]]></title>
    <url>%2F2019%2F04%2F24%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Tomcat-8005%E7%AB%AF%E5%8F%A3Cannot-assign-requested-address%E7%9A%84%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[记一次Tomcat 8005端口Cannot assign requested address : Jvm Bind的经历 一个正在做毕设的老乡遇到的问题：Tomcat启动的时候，报了[8005] Jvm Bind相关的异常，大概内容是端口已被占用的意思。 一. 先从运行/bin/shutdown.bat，再次关闭Tomcat，重新启动问题依然存在； 二. netstat -ano查看端口使用情况，未发现8080,8009,8005相关的端口被占用； 三. 打开任务管理器，确认javaw.exe未在运行，问题依然存在； 四. 重启机器，问题依然存在； 五. 参照：[Tomcat启动报错:严重: StandardServer.await: create[8005] java.net.BindException: Cannot assign requested address](https://www.cnblogs.com/heshan664754022/p/3807672.html) ， ping了localhost，发现收到的响应来自ipp[47.89.54.215]，打开C:/windows/system32/drivers/etc/hosts，发现以下内容： 123456789101112131447.89.54.215 localhost47.89.54.215 hao.360.cn47.89.54.215 www.hao123.com47.89.54.215 www.3600.com47.89.54.215 www.114la.com47.89.54.215 www.duba.com47.89.54.215 www.hao360.cn47.89.54.215 123.sogou.com47.89.54.215 web.sogou.com47.89.54.215 www.hao123.cn47.89.54.215 hao.qq.com47.89.54.215 www.1616.net47.89.54.215 hao.rising.cn47.89.54.215 daohang.qq.com 看到daohang.qq，hao123，duba，hao360，123.sougou之类的字眼，瞬间一阵悲痛袭来，曾经那个“为什么国内流氓软件那么多？”的问题又浮现在脑海，想起了百度所谓的“中国用户愿意用隐私换效率”。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>端口占用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA Terminal闪退]]></title>
    <url>%2F2019%2F04%2F09%2FIDEA-Terminal%E9%97%AA%E9%80%80%2F</url>
    <content type="text"><![CDATA[IDEA Terminal闪退 查看help &gt; Show Log in File，查看日志； 查看File &gt; Settings &gt; Terminal &gt; shell path，=&gt; /bin/bash，重启终端。 Black Terminal or Terminal doesnot work]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
        <tag>IDEA</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置代理]]></title>
    <url>%2F2019%2F04%2F06%2FGit%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[git的代理配置 给sublime安装插件的时候又碰到git clone速度过慢的问题，记录一哈！ 打开ss全局代理； 到 IPAddress.com 根据 github.global.ssl.fastly.net 获取github服务器地址； 在 /etc/hosts 或者C:/windows/system32/driver/etc/hosts 文件中添加对应的记录： ip github.global.ssl.fastly.net 设置git代理： 12345678910111213141516171819202122# http和https协议代理：git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy http://127.0.0.1:1080# sock5的情况git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080# 取消代理git config --global unset http.proxygit config --global unset https.proxy# ssh协议代理：在用户目录下建立如下文件 ~/.ssh/config，对 GitHub 的域名做单独的处理# 这里必须是 github.com，因为这个跟我们 clone 代码时的链接有关Host github.com # 如果用默认端口，这里是 github.com，如果想用443端口，这里就是 ssh.github.com 详见 https://help.github.com/articles/using-ssh-over-the-https-port/ HostName github.com User git # 如果是 HTTP 代理，把下面这行取消注释，并把 proxyport 改成自己的 http 代理的端口 ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=6667 # 如果是 socks5 代理，则把下面这行取消注释，并把 6666 改成自己 socks5 代理的端口 ProxyCommand nc -v -x 127.0.0.1:6666 %h %p ==&gt;&gt; 设置 git 代理 在Ubantu下需要在网络设置里打开网络代理设置代理主机：socks5://127.0.0.1:1080]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清明]]></title>
    <url>%2F2019%2F04%2F06%2F%E6%B8%85%E6%98%8E%2F</url>
    <content type="text"><![CDATA[​ 清明 ​ 今天清明节。 ​ 路边盛开的迎春，宣示着北国漫长的冬季就要在这里画上句号。 ​ 本想早早的起床，一个人出去走一走。但是昨天因为上班没收到显示器，今天想等着快递送来。才七点钟便醒来，然后起床看书。不大一会儿快递就送到了，一同送来的还有昨天晚上买的书。迫不及待地拆了快递，给笔记本连上了，还是大屏幕看着比较舒服，虽然屏幕质量不是很好。 ​ 看着时间两点钟准时出门，在软件园吃了个午饭，随后去了滨海路。 ​ 在车上感觉有点热，怀疑自己穿得太多，可是下了车，又感觉有点冷，不过周围的人貌似穿得都比我少。不知道春天是不是就是这样冷暖不定。春天的风已经没有了寒意，反而带着淡淡的花香。 ​ 到达步道起点大概是下午三点钟光景了。我走在路的内侧，路的外侧尽是迎面往回的人流，还好周围有三五个同方向的人才让我显得奇怪。行人大多三五成群，也有很多情侣同行，独行的大多是慢跑或者骑车。我一路上走走拍拍，山、海、花、草，还特意停下来拍了一只不知道是哪个小孩落下的鞋子。在步道两旁的针叶林中有一些野桃树或是不知到品种的矮小的樱花，现在正是盛开，一些不知名的灌木上也冒出了嫩绿的新芽；少有的几株粗矮的杏树树梢也顶着鼓鼓的花蕾；路旁的垂柳也长出了嫩黄的叶子，有风吹过，纸条也轻柔的摆动着。 ​ 听歌大概是最省电的了，不过后半段路程我还是加快了速度，担心在天黑之前走不完的话，那就是另一个故事了。说是加快速度，其实也就是停下来拍照的次数少了。一路上经过了莲花山、付家庄、燕窝岭、北大桥、老虎滩，把大二时候徒步大会30公里的回忆中的1/2又串联了起来。现在回想起来，那时候真是厉害，完了午饭时间刚过就走完了30KM。 ​ 太阳刚落山，便到达了老虎滩海洋公园，手机也还剩下20%的电，相机也还剩一格电。坐了4路公交到了民政街，看着窗外的风景很是熟悉，一个十字路口，上方是横过的天桥，笔直的人行道旁是开阔地。仔细回想才记起来这是市图书馆附近，上次就是坐的901路到的这里，然后走过一段坡道去的图书馆，不同的是今天我是一个人，或者说那次是和她一起。 ​ 到了住的地方，一路上听的两首轻音乐：《遠き呼び声の彼方へ》和《LOVE Theme from TIGA》已经循环了71次和41次。最近喜欢听悲伤的轻音乐。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3月22日日记]]></title>
    <url>%2F2019%2F03%2F23%2F3%E6%9C%8822%E6%97%A5%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[3月22日日记 四连休，想抽个时间出去走走。本来打算昨天去的，但是打开电脑，看了两集MySQL视频之后，就不怎么想动了。无论昨天晚上多么下多大的决心，睡一觉一切都会烟消云散，去年大概也有过类似的体会。 我决心好好改改自己的拖延症。本来打算早上出门，然后拖到中午，然后拖到吃完中午饭，终于觉得不能再这么拖下去了，才在两点钟收拾一下出了门。 第一站，先去地铁站充个公交卡吧，貌似公交卡四周前就没钱了，存钱罐里的硬币已经捞出了一个大坑，真可怕。地铁站竟然默认使用网络支付，本来我还想把过年时老爸给我的几百块钱赶紧花了，没有能用到纸币的地方，总担心捞东西给弄丢了。 去了锦辉商场，没做停留，买了一张《波希米亚狂想曲》的电影票。印象里，上一次去影院已经是17年的事情了吧，时间过得真快，不对，去年十一月底还请假去和平广场看了漫威的电影来着。 总之吧，随便买的电影票，不是我喜欢的类型，乐队也好，音乐也好，情节也好，主题也好，没有一个符合我的审美。一个半小时仿佛过了半天，耳朵都快聋了，七八十年代的摇滚就是这样的吗，我不太了解音乐。我喜欢安静，喜欢顺其自然，大概只有纪录片才合得着我的口味。不知道圈子里是怎么评价的，权当是打发时间了吧。 年初买的三本书都看完了，想着去万达能逛逛书店，但是没找着书店。还是在晚上回来的公交车上，我旁边的一个女生，手里提着一个袋子，里面装着七本书和一束花，在动荡的车厢里显得有些别致，那鼓着大大的花苞的百合，盛开的时候一定很漂亮。我很想记录下这一刻的所见，但是做不到。 《古都》结束得有些突然，我往后翻页，想知道苗子离开之后，千重子是嫁给龙助还是真一呢，千重子还会到衫村去看望苗子吗，苗子离开之后是不是就不再和千重子来往了呢？我总爱将自己放在苗子的位置，大概是因为我在苗子的身上看到了某些相同的地方。虽然是亲生姐妹，但是千重子生活的很好，她的父母很爱她。假如当年被领养的是苗子的话，大概就是苗子和千重子两人对换，还是相同的故事情节，不过换成了千重子不愿意去妨碍苗子的幸福了吧。我很能理解苗子的想法，真心的希望千重子幸福，并且不去妨碍她的幸福，所以她拒绝了千重子一家的邀请，只和千重子度过了一晚。 秀男错将苗子认成了千重子，然后千重子让秀男给她织了腰带，在给苗子送腰带有过一次独处的机会之后，秀男便觉得自己爱上了苗子。我很佩服苗子的直觉，能从一开始就知道秀男不过是将苗子当成了千重子的幻影，所以在和千重子的谈话中，苗子总爱说一个“幻”字。我想，在和千重子——自己的亲生姐妹度过幸福的一晚之后，苗子大概会像她之前所提到的那样，找一个地方隐姓埋名，不再和千重子往来。临别的一番话，很触动人。“这可能就是我一生的幸福了”。和真一一样，在苗子眼中，千重子是幸福的，她的心里或许有些自卑，她居住的破旧的茅草屋是给不了千重子任何幸福的。但是和千重子共度的一晚，会成为她一生的幸福。 大概千重子会嫁给真一，因为千重子喜欢真一，真一也喜欢千重子，苗子大概会从此隐姓埋名，而龙助大概会离开千重子家的店铺，和其他的人结婚。 千重子的人生可能就是苗子的另一种人生。 正如苗子所说的那样：幸福总是短暂的，只有寂寞才是永恒的。 ​ 苗子把嘴凑到千重子耳边，悄悄地说: 123456789101112&gt; “千重子小姐的床铺已经暖和了，我到旁边的铺位去。”&gt; &gt; 母亲把隔扇拉开一条小缝， 窥视两个姑娘的卧室，那是在这以后的事了。&gt; &gt; 翌日早晨，苗子早就起床，把千重子摇醒:“小姐，这可能就是我一生的幸福了。趁着没人瞧见，我该回去了。”&gt; &gt; 正像昨晚苗子所说的那样，真正的小雪在半夜里下下停停，现在还在霏霏地下着。这是一个寒冷的早晨。&gt; &gt; 千重子坐了起来。“苗子，你没带雨具吧?请你等一等。”千重子说着，把自己最好的天鹅绒大衣、折叠伞和高齿木屐都给了苗子。&gt; &gt; “这是我送给你的。希望你再来啊。”&gt; ​ 苗子摇摇头。千重子抓住红格子门，目送苗子远去。苗子始终没有回头。在千重子的前发上飘落了少许细雪，很快就消融了。整个市街也还在沉睡着。 貌似在我和舍友提了搬出去的事情之后，他女朋友就很少过来了，虽说对于我来说，这正是我所希望的，但是这样一来，仿佛我成了他们之间的障碍。给别人添麻烦这种事，向来是付出多大代价都要极力避免的。尽管我觉得周围的人都不在乎给别人添麻烦。 之前同学说要跟我合租，所以我最近看的房子都是两室一厅的。昨天早上才偶然从另一个同学口中得知，原来她已经找好室友了。我又婉言拒绝了他合租的请求，大概要一个人住这一年了。不过倒也能接受，不需要迁就其他人，与人相处上能省些心思。 近来似乎有些患得患失，不要喜欢上别人才好，我讨厌这种感觉。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在新机器中恢复Hexo博客]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%9C%A8%E6%96%B0%E6%9C%BA%E5%99%A8%E4%B8%AD%E6%81%A2%E5%A4%8DHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在新机器上恢复Hexo博客准备源文件可以备份到github或者coding，或者使用云盘同步（例如坚果云）。 环境准备12345678910111213141516171819202122232425262728##安装npmsudo apt install npm##安装hexosudo apt install -g hexo-cli##克隆源文件git clone user@github.com/repo/##在仓库中添加SSH key##安装部署插件npm install hexo-deployer-git --save##RSS订阅插件npm install hexo-generator-feed --save##站点地图插件npm install hexo-generator-sitemap --save##安装本地服务器npm install hexo-server --save##生成index.html插件$ npm install hexo-generator-archive --save##搜索功能插件npm install hexo-generator-searchdb --save 发布1234hexo clean##预览hexo shexo g -d 问题排查遇到一个问题：生成后访问 http://localhost:4000 出现白版和”Cannot GET /“，”/“是因为在public 目录下少了index.html文件，再次生成还是无效后，确认是少了组件： 1npm install hexo-generator-index 参见：【完美解决】Hexo博客出现“Cannot GET/xxx”错误 吐槽一下coding和腾讯云之间的账号互通问题，一阵瞎引导，竟然创建了一个新账号，以前的项目找不回来，两个网站之间来回绕了几遍，无意间又用邮箱登录上去了，之前都是能自动跳转登录的，现在还和CSDN一样开始恰烂钱，强制绑定微信和手机号，无语。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>Hexo博客维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想——第十四章——类型信息]]></title>
    <url>%2F2019%2F02%2F01%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[第十四章 类型信息标签（空格分隔）： Java编程思想 运行时类型信息可以使得你可以在程序运行时发现和使用类型信息。 本章主要讨论Java如何让我们在运行时识别对象和类的信息，主要有两种方式： “传统的RTTI”，假定我们在编译时已经知道了所有的类型； “反射机制”，允许在运行时发现和使用类的信息。 14.1 为什么需要RTTI(Run-Time Type Identification)RTTI提供类型维护的信息，为多态机制提供实现基础。多态的实现主要是通过向上转型，通过泛化父类来引用子类对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.typeinfo;import java.util.Arrays;import java.util.List;/** * @author zhulongkun20@163.com * @since 2018-06-06 14:52 */public class Shapes &#123; public static void main(String[] args) &#123; List&lt;Shape&gt; shapeList = Arrays.asList(new Circle(), new Square(), new Triangle()); shapeList.forEach(Shape::draw); &#125;&#125;abstract class Shape &#123; void draw() &#123; System.out.println(this + ".draw."); &#125; public abstract String toString();&#125;class Circle extends Shape &#123; @Override public String toString() &#123; return "Circle"; &#125;&#125;class Triangle extends Shape &#123; @Override public String toString() &#123; return "Triangle"; &#125;&#125;class Square extends Shape &#123; @Override public String toString() &#123; return "Square"; &#125;&#125; output: 12345Circle.draw.Square.draw.Triangle.draw.Process finished with exit code 0 14.2 Class对象RTTI的功能主要是由Class类实现的，每个类都是Class类的一个对象。所有的类都是在第一次使用时被”类加载器”动态的加载到JVM中的，当程序创建第一个类的成员引用时，便会加载这个类，这说明构造器是类的静态方法。使用new创建的类的新对象也会被当作类的静态成员，因此Java是动态加载的。首先检查类的Class对象是否加载，如果尚未加载，默认的类的加载器会查找同名的.class文件,一旦某个类的Class对象被载入内存，便会用来创建这个类的所有对象。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 17:07 */public class SweetShop &#123; public static void main(String[] args) &#123; System.out.println("inside main."); new Candy(); System.out.println("after create candy"); new Candy(); System.out.println("after create candy2"); try&#123; Class.forName("com.typeinfo.Gum"); &#125;catch (ClassNotFoundException e) &#123; System.out.println("Class Gum not found."); &#125; System.out.println("after create after gum."); new Cookie(); System.out.println("after create cookie"); &#125;&#125;class Candy &#123; static &#123; System.out.println("Loading candy."); &#125;&#125;class Gum &#123; static &#123; System.out.println("Loading gum."); &#125;&#125;class Cookie &#123; static &#123; System.out.println("Loading cookie."); &#125;&#125; output: 12345678910inside main.Loading candy.after create candyafter create candy2Loading gum.after create after gum.Loading cookie.after create cookieProcess finished with exit code 0 从输出中可以看出，Java中的类都是在需要时才被加载的。forName()是Class类的一个静态成员，调用该方法可以返回相应类的实例。无论何时，若要使用类型信息，必须持有Class对象的引用，Class.forName()是实现此功能的便捷方式，因为不需要再为了获取Class引用而持有该类型的引用。如果已经拥有一个类型的对象，可以使用getClass()来获取Class引用，返回表示该对象的实际类型的Class引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 18:22 */public class ToyTest &#123; private static void printInfo(Class cc) &#123; System.out.println("Class name: " + cc.getName() + " is interface? [" + cc.isInterface() + "]"); System.out.println("Simple name: " + cc.getSimpleName()); System.out.println("Canonical name: " + cc.getCanonicalName()); System.out.println("---------------"); &#125; public static void main(String[] args) &#123; Class c = null; try &#123; c = Class.forName("com.typeinfo.FancyToy"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("class not found."); &#125; assert c != null; printInfo(c); for (Class face : c.getInterfaces()) &#123; printInfo(face); &#125; Class up = c.getSuperclass(); Object object = null; try &#123; object = up.newInstance(); &#125; catch (InstantiationException e) &#123; System.out.println("获取实例失败."); &#125; catch (IllegalAccessException e) &#123; System.out.println("无法访问."); &#125; assert object != null; printInfo(object.getClass()); &#125;&#125;interface HasBatteries &#123;&#125;interface WaterProof &#123;&#125;interface Shoots &#123;&#125;class Toy &#123; Toy() &#123; &#125; Toy(int i) &#123; &#125;&#125;class FancyToy extends Toy implements HasBatteries, WaterProof, Shoots &#123; FancyToy() &#123; super(1); &#125;&#125; output: 12345678910111213141516171819202122Class name: com.typeinfo.FancyToy is interface? [false]Simple name: FancyToyCanonical name: com.typeinfo.FancyToy---------------Class name: com.typeinfo.HasBatteries is interface? [true]Simple name: HasBatteriesCanonical name: com.typeinfo.HasBatteries---------------Class name: com.typeinfo.WaterProof is interface? [true]Simple name: WaterProofCanonical name: com.typeinfo.WaterProof---------------Class name: com.typeinfo.Shoots is interface? [true]Simple name: ShootsCanonical name: com.typeinfo.Shoots---------------Class name: com.typeinfo.Toy is interface? [false]Simple name: ToyCanonical name: com.typeinfo.Toy---------------Process finished with exit code 0 在给forName()方法传递类名是必须使用全限定名。Class类常用方法列表： 方法 描述 getName() 获取全限定类名 getSimpleName() 获取不含包类名 getCanonicalName() 含包名的全限定名 getInterfaces() Class对象所包含的接口 isInterface() 判断Class对象是否是接口 newInstance() 虚拟构造器(该类必须含有默认构造器) getSuperClass() 间接获取Class对象基类 14.2.1 类字面常量Java还提供了另一种方法来生成Class对象的引用，即使用类字面常量，例如 1FancyToy.class; 这样做更加简单、安全，因为它在编译器就会受到检查，因此不需要异常检查，同时根除了对forNam()方法的调用，因此更加高效。类字面常量方法不仅适用于普通的类，也适用于接口，基本数据类型，数组。对于基本包装类型的Class对象。还有一个标准字段TYPE，TYPE字段是一个引用，指向对应的基本类型Class对象。建议使用.class方法，与普通类保持一致 字面常量 标准TYPE字段 boolean.class Boolean.class char.class Char.class byte.class Byte.class short.class Short.class int.class Integer.class long.class Long.class float.class Flocat.class double.class Double.class void.class Void.class 当使用.class来创建Class对象引用时，不会自动初始化该Class对象，包含三个过程的准备： 加载：由类加载器执行，查找字节码，为字节码创建Class对象； 链接：验证类中的字节码，为静态域分配空间，如果必须的话，将解析这个类创建的对其他类的所有引用； 初始化：如果该类具有超类，则对其进行初始化，执行静态初始化和静态初始化块。初始化被延迟到对静态方法或者非静态数据域进行首次引用时执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.typeinfo;import java.util.Random;/** * @author zhulongkun20@163.com * @since 2018-06-07 19:07 */public class ClassInitailization &#123; public static Random random = new Random(47); public static void main(String[] args) throws ClassNotFoundException &#123; Class initable = Initable.class; System.out.println("after create initable ref."); System.out.println(Initable.staticFinal); System.out.println(Initable.staticFinal2); System.out.println(Initable2.staticNonFinal); Class initable3 = Class.forName("com.typeinfo.Initable3"); System.out.println("after create initable3."); System.out.println(Initable3.staticNonFinal); &#125;&#125;class Initable &#123; static final int staticFinal = 47; static final int staticFinal2 = ClassInitailization.random.nextInt(1000); static &#123; System.out.println("Initializing initable."); &#125;&#125;class Initable2 &#123; static int staticNonFinal = 147; static &#123; System.out.println("initializing initable2."); &#125;&#125;class Initable3 &#123; static int staticNonFinal = 74; static &#123; System.out.println("initializing initable3."); &#125;&#125; output: 1234567891011after create initable ref.47Initializing initable.258initializing initable2.147initializing initable3.after create initable3.74Process finished with exit code 0 初始化有效的体现了”惰性”，从Initable的引用创建中知道使用.class创建Class引用不会引发初始化，但是为了产生引用，Class.forName()立即进行了初始化。 如果一个static final值是编译期常量，那么这个值不需要对类进行初始化就可以进行读取。但是将一个域设置为static final不足以确保这种行为，如Initable.staticFinal2的访问强制类进行了初始化。如果一个常量是static但不是final的，那么在对它进行访问时，总是要求在对它进行读取前，先进行链接(分配存储空间)和初始化(初始化该域磁盘)。 14.2.2 泛化的Class引用Class引用所表示的就是它所指向的类的确切类型，可以制造类的实例，包含类的静态成员和方法代码。在Java SE5中Class引用的类型变得更加具体，这是通过允许你Class引用所指向的Class对象引用类型进行限定实现的。 123456789101112131415package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 19:36 */public class GenericClassReference &#123; public static void main(String[] args) &#123; Class intClass = int.class; Class&lt;Integer&gt; genericIntClass = int.class; genericIntClass = Integer.class; intClass = double.class; //genericIntClass = double.class; //编译错误 &#125;&#125; 普通的类引用不会产生警告，尽管泛型类引用只能指向其声明的类型，但是普通的类引用可以被重新赋值为其他任何类型的引用，因此通过使用泛型，可以强制编译器进行类型检查。 如果希望稍微放宽这种限制，如： 1Class&lt;Number&gt; c = int.class; 上述代码产生了编译错误，因为Integer Class对象不是Number Class的子类。为了能够在使用泛化的Class引用时放宽限制，可以使用泛型通配符。 123456789101112package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 19:46 */public class WildcardClassReference &#123; public static void main(String[] args) &#123; Class&lt;? extends Number&gt; c = int.class; c = double.class; &#125;&#125; 上述代码没有产生任何警告信息。Class优于普通的Class，并且两者等价。 **Class的好处是它表示你并非碰巧或者处于疏忽而使用了一个非具体的类型。为了创建一个Class引用，它被限定为某种类型，和extends结合，可以创建一个范围。**使用泛型可以促使编译器在编译器提供类型检查。 将泛型用于Class对象，newInstance()方法返回的将是具体的类型而不是Object。但是这种具体类型有些许限制，由具体类型的Class引用getSuperClass()返回的类型是Object类型。 123456789101112131415package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 20:04 */public class GenericToyTest &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123; Class&lt;FancyToy&gt; fancyToyClass = FancyToy.class; FancyToy fancyToy = fancyToyClass.newInstance(); Class&lt;? super FancyToy&gt; c = fancyToyClass.getSuperclass();// Class&lt;Toy&gt; toyClass = fancyToyClass.getSuperclass(); 编译错误 Object object = fancyToyClass.getSuperclass(); &#125;&#125; 14.2.3 新的转型语法Java SE5还添加了用于Class引用转型的语法，即cast()方法。cast()方法接收参数对象，并将其转型为Class引用的类型。在Java SE5中另一个最没用的新特性就是Class.asSubclass，该方法允许你将一个类对象转为更加具体的对象类型。 1234567891011121314151617package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 20:12 */public class ClassCasts &#123; Building building = new House(); Class&lt;House&gt; houseClass = House.class; House house = houseClass.cast(building);&#125;class Building&#123;&#125;class House extends Building &#123;&#125; 14.3 类型转换前先做检查迄今为止，RTTI的形式包括： 传统的类型转换； 代表对象的类型的Class对象； 关键字instanceof：判断一个对象是不是某个特定类型的实例。 123if(x instaceof Dog) &#123; (Dog)x.bark();&#125; instanceof有比较严格的限制，只可将其与命名类型比较，而不能与Class对象比较。 14.5 instanceof和Class的等价性instanceof()和isInstance()方法生成的结果完全一样，equals和==也完全一样。但是instanceof保持了类型的概念，而==比较的是实际的Class对象，没有考虑继承。 123456789101112131415161718192021222324252627282930package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-07 20:51 */public class FamilyVsExactType &#123; static void test(Object object) &#123; System.out.println("Testing object of type :" + object.getClass()); System.out.println("object instanceof Base: " + (object instanceof Base)); System.out.println("object instanceof Derived :" + (object instanceof Derived)); System.out.println("Base.isInstance(object): " + Base.class.isInstance(object)); System.out.println("Derived.isInstance(object): " + Derived.class.isInstance(object)); System.out.println("object.getClass() == Base.class(): " + (object.getClass() == Base.class)); System.out.println("object.getClass() == Derived.class(): " + (object.getClass() == Derived.class)); System.out.println("object.getClass().equals(Base.class()): " + (object.getClass().equals(Base.class))); System.out.println("object.getClass().equals(Derived.class()): " + (object.getClass().equals(Derived.class))); &#125; public static void main(String[] args) &#123; test(new Base()); test(new Derived()); &#125;&#125;class Base &#123;&#125;class Derived extends Base &#123;&#125; output: 1234567891011121314151617181920Testing object of type :class com.typeinfo.Baseobject instanceof Base: trueobject instanceof Derived :falseBase.isInstance(object): trueDerived.isInstance(object): falseobject.getClass() == Base.class(): trueobject.getClass() == Derived.class(): falseobject.getClass().equals(Base.class()): trueobject.getClass().equals(Derived.class()): falseTesting object of type :class com.typeinfo.Derivedobject instanceof Base: trueobject instanceof Derived :trueBase.isInstance(object): trueDerived.isInstance(object): trueobject.getClass() == Base.class(): falseobject.getClass() == Derived.class(): trueobject.getClass().equals(Base.class()): falseobject.getClass().equals(Derived.class()): trueProcess finished with exit code 0 14.6 反射：运行时的类信息RTTI的限制：如果需要知道某个对象的确切类型，可以使用RTTI，但是有一个限制：这个类型在编译时必须是可知的。如果获取了持有一个不在程序空间内的对象的引用或者这个类在你的程序运行许久之后才出现，此时则无法使用RTTI。 为什么需要反射？ 解决RTTI的限制； 希望提供在跨网络的平台上创建和运行对象的能力，即远程方法调用(RMI)。 Class类与Java.lang.Reflect类库对反射进行了支持，该类库包含Field、Method和Constructor等类。可以用invoke()调用与Method关联的方法，调用getField()、getMethods()和getConstructor()等方法返回表示字段、方法和构造方法的数组。 RTTI与反射之间真正的区别在于对于RTTI来说，编译器在编译时打开和检查.class文件，而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。 14.6.1 类方法提取器123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.typeinfo;import java.lang.reflect.Constructor;import java.lang.reflect.Method;/** * @author zhulongkun20@163.com * @since 2018-06-08 9:45 */public class ShowMethods &#123; private static String usage = "usage"; public static void main(String[] args) &#123; if (args.length &lt; 1) &#123; System.out.println(usage); System.exit(0); &#125; try &#123; Class&lt;?&gt; c = Class.forName(args[0]); Method[] methods = c.getMethods(); Constructor[] constructors = c.getConstructors(); if (args.length == 1) &#123; for (Method method : methods) &#123; System.out.println(method.toString()); &#125; for (Constructor constructor : constructors) &#123; System.out.println(constructor.toString()); &#125; &#125; else &#123; for (Method method : methods) &#123; if (method.toString().contains(args[1])) &#123; System.out.println(method.toString()); &#125; &#125; for (Constructor constructor : constructors) &#123; if (constructor.toString().contains(args[1])) &#123; System.out.println(constructor.toString()); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println("No such class."); &#125; &#125;&#125; output: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public boolean java.lang.String.equals(java.lang.Object)public java.lang.String java.lang.String.toString()public int java.lang.String.hashCode()public int java.lang.String.compareTo(java.lang.String)public int java.lang.String.compareTo(java.lang.Object)public int java.lang.String.indexOf(java.lang.String,int)public int java.lang.String.indexOf(java.lang.String)public int java.lang.String.indexOf(int,int)public int java.lang.String.indexOf(int)public static java.lang.String java.lang.String.valueOf(int)public static java.lang.String java.lang.String.valueOf(long)public static java.lang.String java.lang.String.valueOf(float)public static java.lang.String java.lang.String.valueOf(boolean)public static java.lang.String java.lang.String.valueOf(char[])public static java.lang.String java.lang.String.valueOf(char[],int,int)public static java.lang.String java.lang.String.valueOf(java.lang.Object)public static java.lang.String java.lang.String.valueOf(char)public static java.lang.String java.lang.String.valueOf(double)public char java.lang.String.charAt(int)public int java.lang.String.codePointAt(int)public int java.lang.String.codePointBefore(int)public int java.lang.String.codePointCount(int,int)public int java.lang.String.compareToIgnoreCase(java.lang.String)public java.lang.String java.lang.String.concat(java.lang.String)public boolean java.lang.String.contains(java.lang.CharSequence)public boolean java.lang.String.contentEquals(java.lang.CharSequence)public boolean java.lang.String.contentEquals(java.lang.StringBuffer)public static java.lang.String java.lang.String.copyValueOf(char[])public static java.lang.String java.lang.String.copyValueOf(char[],int,int)public boolean java.lang.String.endsWith(java.lang.String)public boolean java.lang.String.equalsIgnoreCase(java.lang.String)public static java.lang.String java.lang.String.format(java.util.Locale,java.lang.String,java.lang.Object[])public static java.lang.String java.lang.String.format(java.lang.String,java.lang.Object[])public void java.lang.String.getBytes(int,int,byte[],int)public byte[] java.lang.String.getBytes(java.nio.charset.Charset)public byte[] java.lang.String.getBytes(java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic byte[] java.lang.String.getBytes()public void java.lang.String.getChars(int,int,char[],int)public native java.lang.String java.lang.String.intern()public boolean java.lang.String.isEmpty()public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.CharSequence[])public static java.lang.String java.lang.String.join(java.lang.CharSequence,java.lang.Iterable)public int java.lang.String.lastIndexOf(int)public int java.lang.String.lastIndexOf(java.lang.String)public int java.lang.String.lastIndexOf(java.lang.String,int)public int java.lang.String.lastIndexOf(int,int)public int java.lang.String.length()public boolean java.lang.String.matches(java.lang.String)public int java.lang.String.offsetByCodePoints(int,int)public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)public java.lang.String java.lang.String.replace(char,char)public java.lang.String java.lang.String.replace(java.lang.CharSequence,java.lang.CharSequence)public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)public java.lang.String[] java.lang.String.split(java.lang.String)public java.lang.String[] java.lang.String.split(java.lang.String,int)public boolean java.lang.String.startsWith(java.lang.String,int)public boolean java.lang.String.startsWith(java.lang.String)public java.lang.CharSequence java.lang.String.subSequence(int,int)public java.lang.String java.lang.String.substring(int)public java.lang.String java.lang.String.substring(int,int)public char[] java.lang.String.toCharArray()public java.lang.String java.lang.String.toLowerCase(java.util.Locale)public java.lang.String java.lang.String.toLowerCase()public java.lang.String java.lang.String.toUpperCase()public java.lang.String java.lang.String.toUpperCase(java.util.Locale)public java.lang.String java.lang.String.trim()public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll()public default java.util.stream.IntStream java.lang.CharSequence.chars()public default java.util.stream.IntStream java.lang.CharSequence.codePoints()public java.lang.String(byte[],int,int)public java.lang.String(byte[],java.nio.charset.Charset)public java.lang.String(byte[],java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic java.lang.String(byte[],int,int,java.nio.charset.Charset)public java.lang.String(byte[],int,int,java.lang.String) throws java.io.UnsupportedEncodingExceptionpublic java.lang.String(java.lang.StringBuilder)public java.lang.String(java.lang.StringBuffer)public java.lang.String(byte[])public java.lang.String(int[],int,int)public java.lang.String()public java.lang.String(char[])public java.lang.String(java.lang.String)public java.lang.String(char[],int,int)public java.lang.String(byte[],int)public java.lang.String(byte[],int,int,int)Process finished with exit code 0 参数为java.lang.String，在idea中设置运行参数：Edit Configurations&gt;Configuration&gt;Program arguments，需要填写某个类的全限定名。 14.7 动态代理代理是基本的设计模式之一，是用来代替实际对象的对象，通常涉及与实际对象的通信，充当中间人的角色。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 10:22 */public class SimpleProxyDemo &#123; public static void consumer(Interface inter) &#123; inter.doSomething(); inter.somethingElse("banana"); &#125; public static void main(String[] args) &#123; consumer(new RealObject()); consumer(new ProxyObject(new RealObject())); &#125;&#125;interface Interface &#123; void doSomething(); void somethingElse(String arg);&#125;class RealObject implements Interface &#123; @Override public void doSomething() &#123; System.out.println("do something."); &#125; @Override public void somethingElse(String arg) &#123; System.out.println("do something else :" + arg); &#125;&#125;class ProxyObject implements Interface &#123; private Interface proxied; public ProxyObject(Interface proxied) &#123; this.proxied = proxied; &#125; @Override public void doSomething() &#123; System.out.println("proxy object do something."); proxied.doSomething(); &#125; @Override public void somethingElse(String arg) &#123; System.out.println("proxy object do something else: " + arg); proxied.somethingElse(arg); &#125;&#125; output: 12345678do something.do something else :bananaproxy object do something.do something.proxy object do something else: bananado something else :bananaProcess finished with exit code 0 当想要执行一些额外操作，同时想将这些操作从”实际”对象中分离出去时，或者想要更加容易的做出修改时代理是很有用的。 通过调用静态方法Proxy.newProxyInstance()可以创建动态代理对象，newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler. 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.typeinfo;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @author zhulongkun20@163.com * @since 2018-06-08 10:35 */public class SimpleDynamicProxy &#123; public static void consumer(Interface inter) &#123; inter.doSomething(); inter.somethingElse("Banana"); &#125; public static void main(String[] args) &#123; RealObject realObject = new RealObject(); consumer(realObject); Interface proxy = (Interface) Proxy.newProxyInstance(Interface.class.getClassLoader(), new Class[]&#123;Interface.class&#125;, new DynamicProxyHandler(realObject)); consumer(proxy); &#125;&#125;class DynamicProxyHandler implements InvocationHandler &#123; private Object proxied; public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("proxy: " + proxy.getClass() + " .method: " + method + " .args: " + args); if (args != null) &#123; for (Object object : args) &#123; System.out.println(object + " "); &#125; &#125; return method.invoke(proxied, args); &#125;&#125; output: 123456789do something.do something else :Bananaproxy: class com.typeinfo.$Proxy0 .method: public abstract void com.typeinfo.Interface.doSomething() .args: nulldo something.proxy: class com.typeinfo.$Proxy0 .method: public abstract void com.typeinfo.Interface.somethingElse(java.lang.String) .args: [Ljava.lang.Object;@12a3a380Banana do something else :BananaProcess finished with exit code 0 14.8 空对象当时用内置的null去表示空对象时，在每次使用这个对象的时候都需要先判断该对象是否为null，并且判断除了用来产生NullPointerException之外，没有任何帮助，还会产生大量冗余代码。我们希望有一个空对象，可以接收传传给它所代表的对象，但是将返回表示该对象不存在的任何真实对象的值。最简单的是创建一个标记接口。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:02 */public class NullPerson extends Person implements Null &#123; private NullPerson() &#123; super("None", "None", "None"); &#125; public String toString() &#123; return "NullPerson"; &#125; public static final Person Null = new NullPerson();&#125;interface Null &#123;&#125;class Person &#123; public final String first; public final String last; public final String address; public Person(String first, String last, String address) &#123; this.first = first; this.last = last; this.address = address; &#125; @Override public String toString() &#123; return "Person&#123;" + "first='" + first + '\'' + ", last='" + last + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 14.9 接口与类型信息interface的一种重要目标就是允许隔离构件，进而降低耦合度，如果编写接口，那么可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去。 12345678910111213141516171819202122232425262728293031package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:13 */public class InterfaceViolation &#123; public static void main(String[] args) &#123; A a = new B(); a.f(); System.out.println(a.getClass().getCanonicalName()); if (a instanceof B) &#123; B b = (B) a; b.g(); &#125; &#125;&#125;interface A &#123; void f();&#125;class B implements A &#123; @Override public void f() &#123; &#125; public void g() &#123; &#125;&#125; a被当作B实现，通过转型为B，可以调用A中不存在的方法。一种解决方法是直接声明，使用实际的类而不是接口。最简单的方式是对实现使用包访问权限，这样在包外便无法访问。 123456789101112131415161718192021222324252627282930package com.typeinfo;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:27 */public class HiddenC &#123; public static A makeA() &#123; return new C(); &#125;&#125;class C implements A &#123; @Override public void f() &#123; &#125; public void g() &#123; &#125; void u() &#123; &#125; protected void v() &#123; &#125; private void w() &#123; &#125;&#125; 即使从makeA()返回的是C类型，在包外依然无法使用A之外的任何方法。 1234567891011121314151617181920212223242526272829303132package com.typeinfo;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:30 */public class HiddenImplementation &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; A a = HiddenC.makeA(); a.f(); System.out.println(a.getClass().getCanonicalName()); if (a instanceof C) &#123; C c = (C) a; c.g(); &#125; callHiddenMethod(a, "g"); callHiddenMethod(a, "v"); callHiddenMethod(a, "u"); callHiddenMethod(a, "w"); &#125; static void callHiddenMethod(Object object, String methodName) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Method g = object.getClass().getDeclaredMethod(methodName); g.setAccessible(true); g.invoke(object); &#125;&#125; output: 123456789public f().com.typeinfo.Cpublic g().public g().protected v().package u().private w().Process finished with exit code 0 通过反射，仍旧可以调用所有方法，甚至是private方法，如果知道方法名，可以在Method对象上调用setAccessible(true)。甚至使用发布编译后的代码也无法阻止这种情况，因为在发布的jdk中有反编译器便可突破这一限制。内部类与匿名类也无法阻止反射到达并调用非公共访问权限的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.typeinfo;import java.lang.reflect.InvocationTargetException;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:46 */public class InnerImplementation &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; A a = InnerA.makeA(); a.f(); System.out.println(a.getClass().getName()); HiddenImplementation.callHiddenMethod(a, "g"); HiddenImplementation.callHiddenMethod(a, "u"); HiddenImplementation.callHiddenMethod(a, "v"); HiddenImplementation.callHiddenMethod(a, "w"); &#125;&#125;class InnerA &#123; private static class C implements A &#123; @Override public void f() &#123; System.out.println("C.f()"); &#125; public void g() &#123; System.out.println("C.g()"); &#125; void u() &#123; System.out.println("C.u()"); &#125; protected void v() &#123; System.out.println("C.v()"); &#125; private void w() &#123; System.out.println("C.w()"); &#125; &#125; public static A makeA()&#123; return new C(); &#125;&#125; output: 12345678C.f()com.typeinfo.InnerA$CC.g()C.u()C.v()C.w()Process finished with exit code 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.typeinfo;import java.lang.reflect.InvocationTargetException;/** * @author zhulongkun20@163.com * @since 2018-06-08 11:51 */public class AnonymousImplementation &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; A a = AnonymousA.makeA(); a.f(); System.out.println(a.getClass().getName()); HiddenImplementation.callHiddenMethod(a, "g"); HiddenImplementation.callHiddenMethod(a, "u"); HiddenImplementation.callHiddenMethod(a, "v"); HiddenImplementation.callHiddenMethod(a, "w"); &#125;&#125;class AnonymousA &#123; public static A makeA() &#123; return new A() &#123; @Override public void f() &#123; System.out.println("public c.f()"); &#125; public void g() &#123; System.out.println("public c.g()"); &#125; void u() &#123; System.out.println("package u()"); &#125; protected void v() &#123; System.out.println("protected v()"); &#125; private void w() &#123; System.out.println("private w()"); &#125; &#125;; &#125;&#125; output: 12345678public c.f()com.typeinfo.AnonymousA$1public c.g()package u()protected v()private w()Process finished with exit code 0]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在新年来临之际]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%86%99%E5%9C%A8%E6%96%B0%E5%B9%B4%E6%9D%A5%E4%B8%B4%E4%B9%8B%E9%99%85%2F</url>
    <content type="text"><![CDATA[写在新年到来之际 今天是农历腊月二十七，距离新年只有三天，如果不是好多同事都忙着赶车回家、 还要走那些从来没记清的请假流程，那今天和一个平常的周五并无二样。没有特别的感觉，只是隐约中在提醒自己记得收拾行李。 早上才四点不到，请了一天假提前回家的舍友就已经乒乒乓乓的客厅收拾行李了。赶凌晨五点的车这种事情我想这辈子也不会发生在我身上。舍友走了，我却一直没睡着，直到六点多天亮了才迷迷糊糊又睡了一会儿，然后去公司。 相比之下，我还是更喜欢一个人上班的感觉，耳机往耳朵一塞，一路沉浸在自己的世界中，为新的一天调整心态，直到公交到站，唯一的缺憾可能就是这段路程只有短短的十分钟。 今年以来，感觉时间过得越来越快，仿佛每次看日历，都会发现今天是周五。说到这里，我撇过头看了看桌上得日历，还停留在2017年12月31日，竟然已经过去这么久了。这本日历陪着我从北京到大连，竟然已经过去了这么久。 在每个新的时间节点到来之际，总是忍不住要回头看一看。 这一年，1月到6月在学校做毕业设计，和几个在前几年都没有多少来往的同学度过了愉快的半年时间，才发现，原来身边一直有这么多有趣玩得来的人，这差不多算是大学四年最好的回忆之一了。 4月初去了西江苗寨，南方鸟语花香的春天远比北方的凛冽寒风更吸引人。 7月，毕业。社会身份的变化算是今年最大的改变，看到身边很多人对学生时代的留恋，我感到几分庆幸。相比于学生，上班族的身份更让我安心。 8月，入职。尽管公司可能还达不到中等水平，但是总归是有一个暂时落脚的地方。到现在半年多过去了，事实证明了我最初的猜想：在工作中的所见所闻所得可能达不到自己的预期。这也是一直以来最令我困扰的一个问题。希望工作能在我改变之前往好的方面改变。 9月，生活与两个在隔壁公司实习的学弟学妹产生了交集。也算是在学校认识最久的人了，相处了三年多的时间，而且人都很好。偶尔还能聚一聚，说说今后的打算，交流一下自己的想法。 11月，项目进度延迟，整个项目组开始赶工期，时常加班。因为开发中需要用到新工具，所有的东西都要边做边学，工时也越来越短，加班也是常事。不过可能是因为有了实习加班的经历，我倒没有多大的感觉，甚至一开始入职的时候对于每天六点下班的作息总感觉怪怪的：这么早就下班了吗？心里总觉得每天工作到八点才是最合适的。工作时间的延长远远没有来自工作压力让人心疲力竭。一直到现在，度过了紧张的三个月。 工作以后，继续学习的劲头远不如在学校的时候，基本处于三天打鱼两天晒网的状态。半年的时间，学习了”Java编程思想“，”SpringBoot基础“，”EasyUI“，”Spring“。来年要保持更高的学习积极性。 读了张嘉佳的《从你的全世界路过》，《时光倒流》（学校图书馆借的一本美国小说，作者忘记了…），余华的《活着》，林徽因的《你是人间的四月天》，德·雷克的《徒步中国》，马尔克斯的《百年孤独》，青山七惠的《ひとり日和》，川端康成的《时生》，《雪国》，《湖》。 来年还要加强锻炼。12月20日到今天，一共四十天的时间减掉了4kg，来年争取再减掉2kg。 在这座城市生活了四年多的时间，却没有真正去了解过这座城市。希望来年能实现”走遍大连“，”走遍东北“的计划。 今天是今年最后一个工作日，稍微有点冷，早早的到了公司。大家今天都来得有点晚，左右两个同事也是无所事事发了一天呆，而我也因为工作没有进展，一个下午基本都在看自己以前的学习笔记。希望身边的同事来年工作积极性能高一点，不要再像今年一样，8小时中有3个小时玩手机，2个小时睡觉，发呆1小时。 下班回家的路上，刚好碰到公司楼下有卖花的，买了一束花带回来，算是给自己的新年礼物吧。晚上回家洗了衣服，收拾了房间，把花给插上，一个星期没通风的房间，等我洗完衣服回到房间，竟然有股淡淡的清香。没想到在乡下看都不看一眼的野花野草，在这冬天的北方城市中竟有几分难得。 新年之际，祝大家新年快乐，新的一年，身体健康，工作顺利！]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更改DNS为8.8.8.8访问cn.bing.com]]></title>
    <url>%2F2019%2F01%2F24%2F%E6%9B%B4%E6%94%B9DNS%E4%B8%BA8-8-8-8%E8%AE%BF%E9%97%AEcn-bing-com%2F</url>
    <content type="text"><![CDATA[昨天早上开始 https://cn.bing.com 就无法访问： 今天晚上想去 Bing搜索微博 了解一下情况，ping了一下，DNS都是127.0.0.1，将DNS改为8.8.8.8还能正常访问。据说当年Google开始也是出现DNS污染，后来才离开大陆的，想想Bing也没有了，每天只能在百度看百家号那些劣质内容就觉得可怕。 从去年开始就没用百度搜索了，除了CSDN（虽然现在也被广告淹没了）还有点有用的东西。前两天搜点东西，发现不太对，好像所有的结果页面风格都差不多，过两天才看到域名，给我吓到了，前几页全是 baijiahao.baidu.com 的文章。给自己家产品引流无可厚非，但是做到这种程度还能算是一个搜索引擎吗？而且好多文章都是文不对题，可能都没有审核。最令人恶心的是竟然都没有评论功能，可能百度也觉得这些低质量内容开放评论会被喷得体无完肤吧。。。 那时候还没想到是百度搞的导流，还特意去查了各种百度谷歌高级搜索的资料学习了一下，折腾一番但是收效甚微。 想看看大家对百度搜索的看法，看到一篇很火的文章：百度搜索引擎已死 ， 文章举了几个例子，果然全是百家号的恶心内容。 没有竞争对手，才能为所欲为吧。 引用原文中得一句话：写到这里，很是悲哀：偌大的中文互联网竟已堕落到如此境地，连一个搜索引擎都没有了。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《雪国》——川端康成]]></title>
    <url>%2F2019%2F01%2F23%2F%E5%B7%9D%E7%AB%AF%E5%BA%B7%E6%88%90%E3%80%8A%E9%9B%AA%E5%9B%BD%E3%80%8B%2F</url>
    <content type="text"><![CDATA[穿过县界长长的隧道，便是雪国。夜空下一片白茫茫。火车在信号所前停了下来。 一位姑娘从对面座位上站起身子，把岛村座位前的玻璃窗打开。一股冷空气袭卷进来。姑娘将身子探出窗外，仿佛向远方呼唤似的喊道…… 随着秋凉，每天都有昆虫在他房间里的榻榻米上死去。硬翅的昆虫，一翻过身就再也飞不起来。蜜蜂还可以爬爬跌跌一番，再倒下去爬不起来。由于季节转换而自然死亡，乍看好像是静静地死去，可是走近看，只见它们抽搐着腿脚和触角，痛苦地拼命挣扎着。这八叠大的榻榻米作为它们死亡的地方，未免显得太宽广了。 比头发丝还细的麻纱，若缺少雪天天然的潮湿，就很难办了。阴冷的季节对它似乎合适。古时有这样一种说法：三九寒天织出来的麻纱，三伏天穿上会令人觉得特别凉爽，这是由于阴阳自然的关系。 倾心于岛村的驹子，似乎在根性上也有某种内在的凉爽。因此，在驹子身上迸发出的奔放的热情，是岛村觉得格外可怜。 但是，这种挚爱之情，不像一件绉纱那样能留下实在的痕迹。纵然穿衣用的绉纱在工艺品中算是寿命最短的，但只要保管得当，五十年或更早的绉纱，穿在身上照样也不褪色。而人的这种依依之情，却没有绉纱寿命长。岛村茫然的这么想着，突然又浮现出为别的男人生了孩子、当了母亲的驹子的形象。他心中一惊，扫视了一下周围，觉得大概是自己太劳累了吧。 岛村无法相信呈弧状横跨太空的明亮光带竟会如此昏暗。大概是星空比朦胧的月夜更加黯淡的缘故吧。可是，银河比任何满月的时候都要澄澈明亮。地面却没什么投影，奇怪的是，驹子的脸活像一副旧面具，淡淡的浮现出来，散发出一股女人的芳香。 岛村抬头仰望，觉得银河仿佛要把这个大地拥抱过去。 犹如一条大光带的银河，使人觉得好像浸泡着岛村的身体，飘飘浮浮，然后伫立在天涯海角上。这虽是一种冷寂，但也给人某种神奇的魅惑之旅。 “这孩子疯了，她疯了！” 驹子发出疯狂的叫喊，岛村试图接近她，不料被一群汉子连推带搡撞到一边去。这些汉子是想从驹子手里接过叶子抱走。待岛村站稳了脚跟，抬头望去，银河好像哗啦一声，向他的心坎上倾泻了下来。 读了一遍，除了驹子与岛村之间的关系、叶子的出场和去世之外，什么也没留下。没有体会到其中要表达的情感，只是从头到尾蕴含着一股无奈和哀伤。 驹子为了给未婚夫治病而沦为艺伎，倾心于岛村，在岛村看来却是一段徒劳的感情；叶子内心向往大城市的生活，希望离开乡下却未能如愿，牵挂自己在铁路工作的弟弟却无法相见，最终因火灾不幸去世。原本出身大城市衣食无忧想要改革日本舞蹈的岛村，在与驹子的相处以及叶子的去世中从自己的世界中解放了出来，改变了自己一直以来对事物的“徒劳”的看法。 一直以来，困扰岛村的虚无背后的原因，是死亡带来的生命时长的局限，所导致的的人生一切事情的无意义。在叶子死亡的那一刻，岛村看到的，是失去了生命反而显得自由，生命通过变形得到了延续，生和死之间不再那么泾渭分明。如果生死界线真的变得模糊，那困扰岛村的虚无，或许将不复存在。 《雪国》：理解虚无主义，才能读懂川端康成]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《百年孤独》]]></title>
    <url>%2F2019%2F01%2F14%2F%E3%80%8A%E7%99%BE%E5%B9%B4%E5%AD%A4%E7%8B%AC%E3%80%8B%2F</url>
    <content type="text"><![CDATA[人生百年，百年孤独。 第一次听到这个书名，还是初中的时候，这么多年，一直觉得这是个令人敬而远之的名字。 花了三周的时间读完了这本书。书中那些长、拗口还夹杂循环的人名以及人物之间错综复杂的关系，严重影响阅读，最后从网上找了任务关系图，读起来轻松不少。 字里行间充满着孤独，每个人都奋力挣扎一生，却从未逃出孤独。 小城从荒芜走向繁荣，然后逐渐走向衰落。布恩迪亚家族七代人，从出生到死亡不过是剧本中的一场演出，在孤独中出场，最后在孤独中落幕，被飓风抹去，从世人记忆中根除，自永远至永远不会被重复。 “过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂乱且坚韧的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。” “你那么憎恨军人，跟他们斗了那么久，琢磨了他们那么久，最终却变得和他们一样。人世间没有任何理想值得以这样的沉沦最为代价。” “世界不过是身外之物，她的内心不再为任何苦痛而波动。她深深遗憾没能在多年前获得这样的领悟，那时还来得及净化记忆，在崭新的光芒下重建世界，平静地唤回傍晚时皮特罗•克雷斯皮身上的薰衣草味道，并将丽贝卡救出悲惨的境地，而这不是出于爱，也不是出于恨，而是出于对孤独的深切理解。” “岁月流逝，她却永远停留在天真烂漫的童年，对各样人情世故越发排斥，对一切恶意与猜疑越发无动于衷，幸福的生活在自己单纯的现实世界里。” “她意识到奥雷里亚诺·布恩迪亚上校并非像她想的那样，由于战争的摧残而丧失对家人的情感，实际上他从未爱过任何人，包括妻子蕾梅黛斯和一夜风流后随即从他生命里消失的无数女人，更不必提他的儿子们。她猜到他并非像所有人想的那样为着某种理想发动那些战争，也并非像所有人想的那样因为疲倦而放弃了近在眼前的胜利，实际上他成功和失败都因为同一个原因，即纯粹、罪恶的自大。她最终得出结论，自己不惜为他付出生命的这个儿子，不过是个无力去爱的人。” “那个漫无尽头的夜里，赫里内勒多•马尔克斯上校追忆在阿玛兰妲缝纫间里度过的那一去不复返的午后时光，奥雷里亚诺•布恩迪亚上校则苦苦挣扎了数小时，试图抓裂自己孤独的硬壳。自从那个遥远的午后父亲带他去见识冰块，他唯一的快乐时光就是在金银器作坊里打造小金鱼的时刻。他被迫发动三十二场战争，打破与死亡之间的所有协定，并像猪一样在荣誉的猪圈里打滚，最后耽搁了将近四十年才发现纯真的可贵。” “在生命的最后两个小时里，他无法理解为什么自童年时代起一直折磨他的恐惧感消失了。他无动于衷地听着冗长的指控，甚至没想去展现自己刚刚获得的勇气。其实他在意的不是死亡，而是生命，因此听到死刑判决时他心中没有恐惧只有留恋。” 可能鸡汤文说的对，孤独才是人生的本质。 信息社会，人人都能随时随地冲浪上网的时代，这种孤独的感觉来得更加容易。我看到身边的人无时无刻在看着手机屏幕，在回复着各种社交软件的消息，看着不计其数的自媒体的图文信息。我没有体验到其中的乐趣，我从很久以前，就努力做一个和快文化保持距离的人。几乎不网络聊天，几乎不玩游戏。也正因为如此，我经常感到和周围的人格格不入，在学校的时候，周围的同学上学放学路上无时无刻不在聊游戏，久而久之，我便习惯一个人上课下课。 曾经有过一段孤独感很强烈的时期。总是会在一些细枝末节的事物影响下产生强烈的孤独，我甚至常常在过马路的时候想，假如此时此刻我发生车祸，我该向谁求助。仔细想来，大概是工作以后，潜意识里多了一种梦想破灭不得不向现实屈服的失落，自己却未曾察觉；毕业之后，便是独自一人生活，几乎断了所有与周围事物的联系，不曾与人搭话，甚至曾经一个月未曾出门，哪怕是下楼去趟超市。庆幸的是，这种感觉持续了一段时间便消失了，可能是习惯了现在的生活状态。 努力地去摆脱孤独。看一部纪录片、单曲循环一首歌、坐一小时公交去机场和车站看看繁忙的世界，坐48小时的绿皮车去接触更底层的劳苦大众…渐渐的在孤独中忘记孤独，当你去回想昨天，发现不是一片空白的时候，你已经战胜了孤独。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web项目可视化开发工具——WebPerformer]]></title>
    <url>%2F2019%2F01%2F08%2FWeb%E9%A1%B9%E7%9B%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94WebPerformer%2F</url>
    <content type="text"><![CDATA[一个基于Web的现金流管理系统是我进入公司接触的第一个项目。两个半月做测试，两个半月做开发，将近半年，现在开发接近尾声，想好好分析一下这个“新兴工具”。 什么是WebPerformer在Google里搜索“Web Performer”（下文简称“wp”），能搜索到结果173,000,000个结果，可以看到，靠前的结果都是日文的，并且都是版本更新相关的结果。在百度中搜索同样的内容，没有发现有中文结果，在国内应用几乎为0。 wp是“キヤノンITソリューションズ株式会社”的产品，产品简介：wp-官网简介 。 简单来说，wp是为了降低人力成本、应对信息技术发展和技术人才不足、提高软件质量而开发的高效率自动化开发工具。 目前已经在制药、贸易、建设、运输、金融保险等行业有一些成功应用的案例。 wp就是一个功能比较全的Eclipse插件。 与传统Web项目开发的相同点与不同点官网的简介几乎都是一笔带过，并且没有提到细节。应该是只有购买之后才会得到官方详细的使用文档。 Web Performer相关的概念 work code：变量在一个模块（模块包括IO，BP，DM，EXT）的唯一名称，含义和命名规则与Java中的变量相似。 IO：输入输出的意思，在wp中一个IO对应一个页面，页面上所有的项目（数据项，label）都来自在IO中定义的项目，在IO中可以给各个项目添加一些属性，这些属性包括work code（变量名），name（变量别命），长度（区别于byte，例如“name”是4位，“你好”是2位），小数位（项目为数字时且需要小数位时指定，默认-1），数据类型（见“数据类型”部分）。 DM：Data Model的简称，主要功能是作为存放数据的容器。类似于Java中pojo类，兼有泛型集合的功能。 BP：Business Process的简称，BP是一个功能的逻辑部分，大致的使用过程为：向BP传入参数 &gt; BP中加工处理 &gt; 将结果集放入DM &gt; 结果集传到IO &gt; 画面显示数据。 EXT：Extentsion，扩展。某些在BP中不能完成的功能，或者逻辑过于复杂超出了wp的功能范围，可以自己编写相应的Java类或者JavaScript文件，然后通过BP调用EXT，EXT调用自定义处理的方式处理数据。 与传统开发的联系 从wp模块分类中很容易看出，其实wp的本质还是MVC的思想，IO对应View，BP对应Controller，DM对应Model。 在基于wp的开发中，除了扩展部分和自定义页面布局及样式之外，其他所有的操作都接触不到代码，开发的内容仅仅是在各个模块中添加一个个项目，然后给对应的项目指定相应的属性。 开发环境（环境依赖）在开发开始之前，需要搭建开发环境，总体来说wp的开发环境和正常开发时的环境几乎一致。 在wp中，由于wp本质上就是一个Eclipse插件，所以Eclipse是必须的，项目管理基于Maven，构建基于Ant，服务器为Tomcat，自动生成的则是Java代码，所以需要Java环境，其他的与使用Eclipse正常开发几乎一致。常用的功能仅仅是编译时完成一个功能之后点击编译（Eclipse的编译）、需要自定义页面布局时使用Ant命令生成对应IO的layout.html文件然后基于layout.html文件修改页面布局。 数据类型wp中有自己的数据类型，这些数据类型应该是为了降低编程门槛而从Java数据类型中提炼出来的。 数据的类型： CODE：介于Java的String和Numeric之间，定义只包含数字和字母的数据，例如：123，AC01。 TEXT：类似于Java中的String类型，几乎任何类型都可以转换成TEXT类型，例如：’Hello world’。 DATE：日期类型，有多种格式且可以互相转换，例如：20190108，2019-01-08。 TIME：时间类型，有多种精度可以选择，最大精度到秒，例如：2019-01-08 21:59:01。 NUM：数字类型，有多种格式且可以互相转换，例如1234，1,234。 FILE：文件类型。 BOOL：布尔类型，不常用。 CURRENCY：货币类型。 work code的类型： IO：输入输出类型，类似于html中的input类型，页面刷新后输入的值恢复成IO模块中设置的默认值。 I：输入类型，与IO类型类似，页面刷新后输入的值保持不变。 O：输出类型，类似于IO类型的只读模式。 A：Action的简称，执行一个动作，可以调用BP逻辑以执行操作，例如”检索“，”修正“，”删除“。 G：Group的简称，一个组，类似于一个没有边框的table，可以用来展示检索出的数据，在其后并且下一个G类型项目之前的所有IO属性”Level“值为”2“的项目会被组织到这个table中作为表头（一般项目的Level值为1），值会被添加到这个label下，形成完成的数据表格。 BP中项目的常用类型： ARG：参数类型，表示该值是IO中传过来的变量。 CALL：表示调用一个DM并执行DM中的一个操作，例如SELECT，UPDATE。 PROCEDURE：表示调用一个存储过程。 FOREACH：对一个集合执行for循环，类似于Java中的增强for循环。 BREAK：跳出当前循环。 CONTINUE：跳过本次循环进入下一次循环。 DO/WHILE：类似于Java中的WHILE。 IF/ELSEIF/ELSE：判断语句。 END：表示一个逻辑块的结束。 LOG：日志记录。 WORKAREA：表示调用一个数据集合。 DM中操作的类型： SELECT：表示按照指定的条件执行select语句。 UPDATE：表示按照指定的条件执行update语句。 DELETE：表示按照指定的条件执行delete语句（符合条件的记录不存在时报错）。 ERASE：表示按照指定的条件执行delete语句（符合条件的记录不存在时不报错）。 INSERT：表示按照指定的条件执行insert语句。 语法DM的定义DM主要定义一些与数据库或者页面需要的字段，如下表： 项目CODE 项目别名 位数 小数位 字段操作 页面跳转 来自DM DM字段 TRAN_ID 交易编号 13 -1 CODE TRAN_DATE 交易日期 8 -1 CODE TRAN_VOLUME 交易额 15 0 NUM 在DM的属性中可以指定SQL语句，也可以在操作中指定数据库操作类型及条件： 项目CODE 项目别名 项目类型 条件 SELECT_DATA 数据查询 SELECT TRAN_DATE&gt;FORMATDATE(@1,1) AND CUSTOMER_CODE = TEXT(‘TEST_CODE’) AND TRAN_VOLUME &gt; NUM(@2) 其中@1表示调用时的第一个参数，@2表示第二个参数，依此类推，但是必须保证传递过来的参数与定义时的参数顺序一致，否则会得到期待值以外的结果；另外还需要保证SQL返回的结果与DM中字段数量、字段名和顺序一致，否则无法通过编译。 如果要给一个DM的对象赋值，需要在DM中定义赋值方法，分别指定字段以及对应的参数。 BP的定义BP是一个功能模块的逻辑部分，一个简单的示例定义如下： 项目类型 对应DM 调用操作 数据类型 参数 WORK CODE ARG CODE TRAN_DATE ARG TEXT CUSTOMER_ID ARG NUM TRAN_VOLUME CALL TRAN_INFO SELECT_DATA _ARG_.TRAN_DATE,_ARG_.CUSTOMER_ID,_ARG_.TRAN_VOLUME TRAN_INFO CALL PAGE_DATA SET_DATA TRAN_INFO PAGE_TRAN_INFO WORKAREA PAGE_DATA APPEND,PAGE_TRAN_INFO 这时只要在IO中指定数据来源类型为WORKAREA并且为PAGE_DATA，这个数据集合中的数据便能在页面展示出来。 IO的定义IO主要存放与页面交互的数据或者接收用户的输入，可以设定初期值： 项目类型 项目CODE 项目别名 位数 小数位 加工式 目标页面 来自DM DM字段 IO USER_NAME 用户名输入框 20 -1 @TEXT O TRAN_ID 交易ID 15 -1 PAGE_DATA TRAN_ID O TRAN_DATE 交易日期 10 -1 PAGE_DATA TRAN_DATE O TRAN_VOLUME 交易额 15 0 PAGE_DATA TRAN_VOLUME 更多细节程序运行中，数据流向为：IO &gt; BP &gt; DM &gt; BP &gt; IO，不过这个顺序不严格界定，也可以从IO项目的初期值属性中直接访问数据库取得数据，多用于取全局变量等类型的值。 常用内置方法 CODE() / TEXT() / NUM() / DATE() / TIME()：基本数据类型之间的互相转换。（某些数据类型之间不能互转，转换失败会导致编译失败）。 FORMATDATE(DATE,STYLE)：日期格式转换，1：yyyy-MM-dd；3：yyyyMMdd等。 ADDDATE(DATE,Y,M,D)：日期DATE上加Y年M月D日后的日期，若Y/M/D为负时则执行减操作。 SUBSTITUTE(TEXT,TEXT1,TEXT2)：将TEXT中的TEXT1全部置换为TEXT2。 一般开发流程（一个增/删/改/查的例子）原本打算遵循一般使用流程完成一个增/删/改/查的例子，但是考虑到版权问题，此处略过。大致的使用和上文描述并无太大差距。 页面风格与页面布局默认页面布局与页面风格在软件中，内置了几种风格，对于一般对于页面美观程度要求不高的公司内部项目来说已经足够，其实这也差不多就是这个工具软件的使用范围，规模更大或者要求较多的面向用户的项目来说，这个工具显得力不从心。 自定义页面布局与元素样式每定义一个项目，wp会默认纵向排列，可以在项目属性中指定排列方向为X方向。当默认Layout满足不了需求时，就需要自己改变默认布局，在项目编译完成后，使用Ant生成默认的布局文件，然后对默认布局文件layout.html进行修改，直至满足需求。 其实默认Layout就是一个整的table，每一个项目都定义在td单元格中，因此本质上就是改动一个table。 浅谈使用WebPerformer的利与弊基于两个月的使用感受，总结出下面几点： 优点 提高开发效率：对于简单的页面（例如检索数据然后展示），可以免去编写页面的工作，可以快速实现功能，开发效率确实能提升不少。但是这仅仅限于极少数极为简单的页面。 降低开发门槛：wp能极大的降低开发门槛，这是我觉得最大的优点。开发者不用去了解泛型和反射的细节、不用去了解多线程、更不需要了解设计模式的知识，全程“傻瓜式”编程，只要你会使用鼠标和触摸板、知道怎么写一个SQL语句，然后剩下的问题都是wp工具使用的问题。 减小开发难度：因为所有项目的属性已经被工具限定范围，开发者能进行的操作早已被工具限制，所以开发中遇到的关于语言使用本身最严重的错误就是NPE，大大减少了编程错误。 弊端 丧失灵活性是为使用简单付出的代价。到目前为止，使用了wp将近两个月的时间，最大的感觉就是 限制太多 。比如一个页面的数据只能来自一个DM，BP内做循环等，流程繁琐。 代码可读性几乎为0。由于同一模块中不能有相同变量名和逻辑段缩进不灵活的原因，导致BP部分的代码可读性几乎为零。后期维护将会是一个艰巨的任务。 代码复用率低。由于工具本身的特征，很难写出通用功能，整个项目中，每个人几乎都是各自为战，花了太多时间去重复造轮子。 可能存在许多性能问题。由于工具本身限制丧失了许多灵活性，很多明明两行代码就能做到的事情，在wp中却不得不另寻出路，拐弯抹角才能达到目的，由此导致许多性能上的损失。 个人使用感受因为前期没有培训，完全是自己研究文档、在开发中自己摸索，所以整个过程用得很是憋屈。 现阶段离可视化自动化还过于遥远，反正我以后再也不想接触这个工具了，我无法忍受各种限制以及为了向这些限制而在代码性能以及代码可读性等方面做出的让步。 在官网的介绍上赫然挂着“超高速开发”几个字，但是较为讽刺的是，目前这个为期半年的项目已经延期一个多月。 发展前景工具总是朝着简单易用和自动化的方向发展。wp应该算是在这个方向上走得比较远的工具，尽管现在还有许多功能满足不了需求，但是随着不断更新，很多问题应该会逐渐解决。包括在使用范围上应该也会逐渐扩大。但是对于一些规模较大以及性能要求高的系统来说，wp还有很长很长的路要走。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要学摄影]]></title>
    <url>%2F2019%2F01%2F05%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E6%91%84%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[为什么要学摄影？ 原文由 刘星文 发布于简书 为什么要学摄影 ，未经作者本人授权，禁止转载。 2017.12.07 12:45* 字数 1755 转眼，已是冬天。 好像刚刚在春天的繁花下打了个盹，醒来却已是年尾。 而回望过去，照片成了最好的载体，每一张都记录着当时的风，空气的温度，阳光照在身上的温暖…… 好像，那一刻又被激活了。 西湖 所有图片均使用 iPhone 5 或 iPad Pro 拍摄 过完春节那段日子，天气出奇地好，阳光和煦，一切都充满无限的生机。 每一刻，我都想待在室外。 拍这张照片的时候，天空无比清澈通透，傍晚的夕阳洒在江面上，美的像梦境。 我用慢快门拍摄了水面，让它像镜子一样光滑。 那天很冷，风大雨大。 一个人去了浴鹄湾，里面空空荡荡，很少看到人。 虽然冻的手不听使唤，却庆幸捕捉到这样的景色。 这张照片是在一个小桥上拍到的，一棵树花开得正盛，特别惹眼。 有时候风雨越大，景色越美。 那天，去了九溪。 美好的春日，一路上都是郊游的人。 阳光很暖，我走了很远，在亭子边休息时下了这张照片。 后来很多人问这是不是林芝？ 其实那棵树并未开花，但由于光线的神奇缘故，却呈现出了奇妙的颜色。 骑行时偶遇的一个村庄。 庄子的对面是富春江上的一个小岛。 岸边开满了油菜花，水平如镜，真的是如诗如画，都舍不得闭眼。 我在码头边睡了一个小时。 后来又去了几趟，再也没碰到过第一次看到的美景。 梅花开得盛的时候，去了植物园。 早早便入园，赏梅的，遛鸟的，非常热闹。 各种颜色的梅花争芳斗艳，很是壮观。 在植物园逗留了半天，边想心事边拍照，出来的时候，感觉心事少了很多。 这其实是西溪的一朵梅花，用微距拍摄了花蕊。 那天很冷，出门的时候本想多穿件毛衣，犹豫了下，又放下了，结果到了西溪，手都冻僵了。 这其实是我第一次去西溪里面，确实很美。 坐了游船，虽说下着雨，但还是打开窗户，不停地拍沿途的风景。 后来找到了一个很安静的小亭子，在那里拍到了一个极美的镜头，梅花倒映在水面，瞬间就理解了什么叫“疏影横斜水清浅”。 在亭子里待了很久，不停地从各种角度拍梅花，由于亭子上的小台阶太滑了，结果摔了一跤，疼的我直咧嘴。 出园的时候，看到了远山冒着氤氲的水气，美得不忍离开。 那天傍晚的西湖，落日极美。 天空有很厚的云层，阳光穿过，炫目且有些刺眼。 头有些晕，晃晃悠悠中看到了这颗树，落日的余晖中，枝干显得特别有力。 这天的风很大，感觉人都被吹得飘起来了，看看柳条就知道。 这时候柳芽还很小，现在一晃都绿树成荫了。 很冷的一天。 还未完全抽芽的草地还是一片嫩黄，被包裹在在群山与水面之间。 有时候，越是恶劣的天气，越有难得的风景。 元宵节。 街上还很冷清，江边公园里行人也不多。 用了 Slow Shutter 慢快门相机，效果很好。 依然很冷，月亮很圆，当然，手机不可能拍到这么大的月亮，这是我在手机上用 APP 加上去的。 戴家山，久闻其名，终见真容。 雨时大时小，山路真的是非常曲折，但风景奇美，随处可见可见大大小小的油菜花田。 在山上走了好久，有时候水气弥漫真个山谷，如仙境一般。 去看了山里的书店，很别致。 那天傍晚的时候，去了江边。 很多植物已经郁郁葱葱，叶片在阳光下泛着金色。 逆光的时候，树叶更美。 于是逆光拍摄了一片树叶。 风大雨大的一天。 远山层层叠叠，用慢快门相机稍微抖动着拍了一张模糊的照片，在 VSCO 里稍微调色之后，就得到了一张诗意盎然的作品。 被雨打落在地的一朵花。 轻轻地放在一张随身携带的卡纸上。 调成黑白，出奇地有质感。 有天，很早去了一家书店。 很安静，有几个人在安静地看书。 阳光透过巨大的落地窗洒进来，很是惬意。 一个城市，如果有几个 24 小时书店，是件很幸福的事情。 特别喜欢这巨大的玻璃，无比通透。 桌椅很舒服，光线正好，越来越喜欢呆在这里。 环境，真的是非常非常重要。 沿江骑行时，在一个村庄看到这辆这行车，早上的阳光照过来，光影极美。 芦茨。 水特别清，小鱼特别多。 慢快门拍了流水，呈现出一片如诗的静谧。 欲把西湖比西子，淡妆浓抹总相宜。 远山层层叠叠，而那只风筝，在高空中遥望着群山。 江上起雾时，这座小城便犹如仙境一般。 桐君山上的一处老建筑。 下午的光影，极美。 这一张张的照片，就像一个个独立的时空，存储着那一刻的记忆。 如果记忆就是人生的全部，那摄影，就是通向记忆的桥梁。 这也许就是摄影的意义，从短暂的每一刻，瞥见人生的全貌。 如何用手机拍出电影感的画面？ 如何彻底摆脱低效，成就高效人生？ 如何用黄油相机轻松做美图？ 手机都没玩好 ，还想拍出好照片？ 这些 APP，让你的照片美到飞起来 必看，20部摄影超美的电影 最不起眼的习惯，就这样拉开你和别人的距离！ © 著作权归原作者所有]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之3Sum]]></title>
    <url>%2F2019%2F01%2F03%2FLeetCode%E4%B9%8B3Sum%2F</url>
    <content type="text"><![CDATA[不知道身边现在还有没有用QQ音乐的人。 题目内容输入一个数组，例如{-1 0 1 2 -1 -4}，从数组中找三个数（a,b,c），使得其和0，输出所有的（a,b,c）组合。 要求abc不能重复，并且a&lt;=b&lt;=c。 例： S = {-1, 0, 1, 2, -1, -4}； 输出： (-1, 0 ,1) (-1, -1, 2) 分析一看到题目，不问代码行数，不问时间复杂度，便排出三个循环。。但是循环非常耗时，显然不是题目的本意。想了好长时间没有什么进展。 先将给定数组排序，然后指定一个数，在数组中找出两个数并且这两个数的和是目标数值的相反数：【LeetCode】3Sum 解题报告 在网上找到了篇比较有新意的文章：[3Sum algorithm - 非常容易理解的实现 （java)] 。 最后发现维基百科中就有收录：维基百科—3SUM ，还有更一般的情形 N SUM。 12345678910111213141516171819sort(S);for i=0 to n-3 do a = S[i]; start = i+1; end = n-1; while (start &lt; end) do b = S[start] c = S[end]; if (a+b+c == 0) then output a, b, c; // Continue search for all triplet combinations summing to zero. end = end - 1 else if (a+b+c &gt; 0) then end = end - 1; else start = start + 1; end endend 伪代码还挺容易理解的。 Other因为知乎上有人宣称证明了哥德巴赫猜想的原因，这两天还特意了解了下猜想证明的历史，“1+2”、“1+3”之类的证明，虽然一点也没看懂。感觉数学真的很有魅力，严谨清晰的逻辑，精妙完美的结论，自然界中的一切每时每刻都在遵循着其中的规律运行，更加感慨于人类的智慧，都找不到合适的赞美的词了。 “超越数”、“黄金分割”、“哥德巴赫猜想”、“黎曼猜想”… 停下思绪，回到现实：当你理解它的时候你觉得进入了天堂，当你不理解它的时候你仿佛进入了地狱，看哭了…]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot基础学习笔记]]></title>
    <url>%2F2019%2F01%2F01%2FSpringBoot%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内容概要 SpringBoot入门 SpringBoot配置 SpringBoot与日志 SpringBoot与Web开发 SpringBoot与Docker SpringBoot与数据访问 SpringBoot启动配置原理 SpringBoot自定义Starters SpringBoot与缓存 SpringBoot与消息 SpringBoot与检索 SpringBoot与任务 SpringBoot与安全 SpringBoot与分布式 SpringBoot与开发热部署 SpringBoot与监控管理 第一章 SpringBoot入门1.1 SpringBoot简介特点：约定大于配置；去繁从简； 背景： J2EE笨重的开发； 繁多的配置； 低下的效率； 复杂的部署； 第三方技术集成难度大； 解决方案： SpringBoot：一站式J2EE的解决方案； SpringCloud：分布式整体解决方案； 优点： 快速创建可独立运行的Spring项目并与主流框架集成； starters自动依赖管理及版本控制； 使用嵌入的Servlet容器，应用无需打包； 大量的自动配置，简化开发，也可修改默认值； 无需配置XML，无代码生成，开箱即用； 准生产环境的运行时应用监控； 是对Spring技术栈的一个整合。 1.2 微服务单体应用： 开发，测试，部署简单； 微服务：功能拆分，灵活配置，通信协作。 SpringBoot官网 &gt; 微服务文档 1.3 开发环境配置 JDK版本； maven版本； 开发工具选择； 框架版本选择； 1.4 第一个应用：HelloWorld 创建一个Maven项目； 导入SpringBoot相关依赖； 编写主程序，启动SpringBoot应用； 123456@SpringBootApplicationpublic class MainApp &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApp.class, args); &#125;&#125; 编写业务逻辑，服务； 运行主程序测试； 打包jar包： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 运行jar包： 1java -jar xxx.jar 1.5 HelloWorld原理探究POM文件： 父项目： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;父项目： SpringBoot的版本仲裁中心，导入依赖不需要写版本号。 导入的依赖： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; spring-boot-starter-web： 场景启动器：帮我们导入web模块正常运行所需的依赖的组件； 将所有的功能场景抽取出来，做成启动器，只需要在项目中导入相关的starter，所有的依赖都会被导入，版本由spring-boot自动管理。 1.6 主程序类原理探究123456789101112131415package com.hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author zhulongkun20@163.com * @since 18-9-9 下午2:28 */@SpringBootApplicationpublic class MainApp &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApp.class, args); &#125;&#125; @SpringBootApplication标注在某个类上，指定SpringBoot的主配置类，由这个类来启动SpringBoot应用。 1234567891011121314@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125; @SpringBootConfiguration：标注在某个类上，表示该类是SpringBoot的配置类。 @Configuration：配置类上标注该类。配置类也是一个组件：@Component； @EnableAutoConfiguration：开启自动配置， 1需要配置的东西由SpringBoot自动配置。 12@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;) 123@AutoConfigurationPackage：自动配置包，给容器导入一个组件，导入的组件由AutoConfigurationPackage.Registrar；将主配置类所在的及以下所有的子包里的所有组件添加到Spring容器中。 123@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; 123@Import：给容器中导入一些组件：AutoConfigurationImportSelector：选择哪些组件导入。 给容器中导入自动配置类（xxxAutoConfiguration）：给容器中导入场景需要的所有的组件并配置好这些组件。 12345protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."); return configurations;&#125; SpringBoot启动的时候从类路径下META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值导入到Spring容器中，自动配置类生效。 需要自己指定的配置，已经由配置类自动配置好。 org/springframework/boot/spring-boot-autoconfigure/2.0.4.RELEASE/spring-boot-autoconfigure-2.0.4.RELEASE.jar!/META-INF/spring.factories 1.7 SpringBoot项目初始化器SpringBoot项目向导： IDEA &gt; New Project &gt; Spring Initializer &gt; 项目详情 &gt; 导入相关场景依赖。 @RestController注解： @ResponseBody和@RequestMapping注解组合。 自动生成主程序； /resources中目录结构： static：保存静态资源； templates：存所有的模板页面(使用嵌入的tomcat，不支持JSP页面，但是可以使用模板引擎)； application.properties：SpringBoot的默认配置文件。 第二章 SpringBoot配置文件2.1 SpringBoot配置文件SpringBoot使用全局配置文件，配置文件名是固定的。 application.properties； application.yml。 配置文件的作用：修改SpringBoot默认配置。 YAML：不仅仅是一个标记语言，以数据为中心，比json和xml更适合做配置文件。 YAML： 12server: port: 8081 2.2 YAML基本语法key: value 表示键值对，冒号之后的空格必须有的，以空格来控制层级关系。 123server: port: 8081 path: /hello 属性和值大小写敏感。 字面量：字符串默认不加单引号和双引号，双引号会转义特殊字符，单引号会转义特殊字符。 1k: v 对象(属性和值)：本质是键值对。 123student: name: 张三 age: 14 行内写法： 1student: &#123;name: 张三,age: 15&#125; 数组(List, Set)： 用-表示数组中的一个元素。 1234pets: - cat - dog - pig 行内写法： 1pets: [cat,dog,pig] 2.2.1配置文件注入：application.yml文件： 1234567891011121314151617server: port: 8081person: name: 张三 age: 18 alive: true birth: 2018/09/11 classes: - v1 - v2 map: k1: v1 k2: v2 dog: name: dog age: 4 JavaBean： 12345678910111213141516171819202122232425262728293031323334353637package com.demo.po;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * @author zhulongkun20@163.com * @since 18-9-11 下午8:36 */@Component@ConfigurationProperties(prefix = "person")public class Student &#123; private String name; private Integer age; private boolean alive; private Date birth; private List&lt;String&gt; classes; private Map&lt;String, Object&gt; map; private Dog dog; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + ", alive=" + alive + ", birth=" + birth + ", classes=" + classes + ", map=" + map + ", dog=" + dog + '&#125;'; &#125;&#125; 可以导入配置文件处理器之后，编写配置文件有IDE智能提示。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; @ConfigurationProperties(prefix = “person”)获取配置文件的值。 application.properties乱码问题：file encoding勾选将properties配置文件转换成ascii码。 配置文件的旧写法： 123&lt;bean class="person"&gt; &lt;property name="lastName" value="zhagsa"/&gt;&lt;/bean&gt; 2.2.2 @Value注入值123456789101112public class Student &#123; @Value("$&#123;person.name&#125;") private String name; @Value("#&#123;11*2&#125;") private Integer age; @Value("true") private boolean alive; private Date birth; private List&lt;String&gt; classes; private Map&lt;String, Object&gt; map; private Dog dog;&#125; 2.2.3 @Value和@ConfigurationProperties获取值比较： @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 单个指定变量的值 松散绑定 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 2.2.4 @Value和@ConfigurationProperties的比较如果只是在某个业务逻辑中需要获取一下配置文件中的值，那就用@Value；如果专门编写了Java bean和配置文件进行映射，就直接使用@ConfigurationProperties。 1234567891011121314151617181920package com.demo.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author zhulongkun20@163.com * @since 18-9-12 下午9:30 */@RestControllerpublic class DemoController &#123; @Value("$&#123;person.name&#125;") private String name; @RequestMapping("/demo.do") public String sayHello() &#123; return "Hello, " + name; &#125;&#125; 2.3 @PropertySource和@ImportSource@ConfigurationProperties默认从全局配置文件中获取值。 2.3.1 @PropertySource获取配置文件的值：12@ConfigurationProperties(prefix = &quot;person&quot;)@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;) 2.3.2 @ImportSource：导入Spring配置文件，是配置文件中的配置生效。SpringBoot默认没有加载Spring配置文件，手动编写的配置文件也无法识别，想让配置文件生效，将@ImportSource标注在主配置类上。 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="demoService" class="com.demo.service.DemoService"/&gt;&lt;/beans&gt; 12345678@Autowiredprivate ApplicationContext applicationContext;@Testpublic void demoServiceTest() &#123; boolean hasDemoService = applicationContext.containsBean("demoService"); System.out.println(hasDemoService);&#125; 2.3.3 SpringBoot推荐的添加组件方式SpringBoot推荐给容器中添加组件的方式：使用全注解，@Configuration标注配置类。 @Bean：将方法的返回值添加到容器中，组件的默认id就是方法名。 12345678910111213141516171819202122package com.demo.config;import com.demo.service.DemoService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author zhulongkun20@163.com * @since 18-9-12 下午9:52 */@Configurationpublic class AppConfig &#123; /** * @return * @desc 将方法的返回值添加到容器中，组件的默认id就是方法名 */ @Bean public DemoService demoService() &#123; System.out.println("给容器中添加组件"); return new DemoService(); &#125;&#125; 2.4 配置文件占位符1234567891011121314151617server: port: 8081person: name: 张三$&#123;random.value&#125; age: $&#123;random.int&#125; birth: 2018/09/11 map: k1: $&#123;random.value&#125; k2: v2 dog: name: $&#123;person.hello:defau&#125; age: 4 alive: true classes: - v1 - v2 随机数： ${random.value}，${random.int}，${random.long}，${random.int(10)}，${random.int[1,10]} 占位符获取配置之前的值，${app.name:默认值} 2.5 Profile多环境支持 profile为不同环境提供不同配置的功能。 多profile文件的方式： 在主配置文件编写的时候，文件名可以是application-{profile}.properties/application-{profile}.yml； SpringBoot默认使用全局环境配置 激活指定profile： 123spring: profiles: active: dev 命令行方式： –spring.profiles.active=dev/prod 虚拟机参数： -Dspring.profiles.active=dev/prod yaml支持文档块的方式： 123456789101112131415161718server: port: 8080spring: profiles: active: dev---server: port: 8083spring: profiles: dev ---server: port: 8084spring: profiles: prod 见下图： 2.6 配置文件加载位置SpringBoot启动会扫描以下位置的application.properties或者application.yml文件作为SpringBoot的默认配置文件： file：./config/ file：./ classpath：/config/ classpath：/ 以上位置优先级从高到低。所有位置的配置文件都会被加载，高优先级的配置会覆盖低优先级的配置，高优先级和低优先级配置文件形成互补配置。 server.context-path=/config02 -&gt; http://localhost:8080/config02/hello.do 还可以通过spring.config.location来改变默认的配置文件位置(项目打包后可以使用命令行参数的形式启动项目时候来指定配置文件的位置，指定的配置文件和默认加载的配置文件会形成互补配置)。 见下图： 2.7 外部配置文件加载顺序SpringBoot也可以从以下位置加载配置文件，优先级从高到低，高优先级的配置会覆盖低优先级的配置，高低优先级的配置会形成互补配置。 Devtools global settings properties on your home directory (~/.spring-boot-devtools.properties when devtools is active). @TestPropertySource annotations on your tests. @SpringBootTest#properties annotation attribute on your tests. Command line arguments. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property). ServletConfig init parameters. ServletContext init parameters. JNDI attributes from java:comp/env. Java System properties (System.getProperties()). OS environment variables. A RandomValuePropertySource that has properties only in random.*. Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants). Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants). Application properties outside of your packaged jar (application.properties and YAML variants). Application properties packaged inside your jar (application.properties and YAML variants). @PropertySource annotations on your @Configuration classes. Default properties (specified by setting SpringApplication.setDefaultProperties). 由jar包外向jar包内进行查找。 命令行参数（多个参数用空格分开）； java -jar xxx.jar –server.port=8081 server.context.path=/ab 优先加载带profile的配置文件。 jar包外的application-{profile}或application-{yml}或不带spring.profile的配置文件； jar包内的application-{profile}或application-{yml}或不带spring.profile的配置文件； 再加载带不profile的配置文件。 jar包外的application-{profile}或application-{yml}或不带spring.profile的配置文件； jar包内的application-{profile}或application-{yml}或不带spring.profile的配置文件； @Configuration注解类上的@PropertySource； 通过SpringApplication.setDefaultProperties指定的默认属性。 详细参见SpringBoot官网：SpringBoot外部配置文件加载顺序 2.8 自动配置原理配置文件能写什么，怎么写？ 自动配置原理： SpringBoot在启动的时候加载主配置类，开启了自动配置功能：@EnableAutoConfiguration； @EnableAutoConfiguration的作用： 利用@EnableAutoConfigurationImportSelector给容器导入一些组件； 可以查看selectImports中的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes) 方法； SpringFactoriesLoader.loadFactoryNames()； 扫描所有jar包类路径下：META-INF/spring.factories； 将扫描到的文件内容加载包装成properties对象。 每一个自动配置类进行功能的自动配置； 所有在配置文件中能配置的属性都在xxxProperties类中配置着，配置文件能配置什么都参照配置文件中的值； SpringBoot的特点： SpringBoot启动时会加载大量的自动配置类； 看SpringBoot有没有自动配置类； 如果有，不用自己再写自动配置类。 给容器中自动配置类添加组件的时候，会从properties类中读取某些属性，我们就可以在配置文件中指定这些属性的值。 2.9 @Conditional自动配置 自动配置类需要在一定条件下才能生效。 注解的作用：必须是@Conditional指定的条件成立，才能给容器中添加组件，配置里面的所有内容才生效。 @Conditional扩展 作用(判断是否满足当前条件) @ConditionalOnJava 系统的Java版本是否符合要求 @ConditionalOnBean 容器中存在指定的bean @ConditionalOnMissingBean 容器中不存在指定的bean @ConditionalOnExpression 满足SpEL表达式 @ConditionalOnClass 容器中有指定的类 @ConditionalOnMissingClass 容器中没有指定的类 @ConditionalOnProperty 系统中指定属性是有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 @ConditionalOnSingleCandidate 容器中只有一个指定的bean，或者这个bean是首选的bean 自动配置文件：org/springframework/boot/spring-boot-autoconfigure/2.0.5.RELEASE/spring-boot-autoconfigure-2.0.5.RELEASE.jar!/META-INF/spring.factories 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 开启SpringBoot的debug，可以通过debug=true让控制台打印自动配置报告，便可以方便的知道哪些自动配置类生效了。 12345678910111213============================CONDITIONS EVALUATION REPORT============================Positive matches:----------------- CodecsAutoConfiguration matched: - @ConditionalOnClass found required class &apos;org.springframework.http.codec.CodecConfigurer&apos;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) CodecsAutoConfiguration.JacksonCodecConfiguration matched: - @ConditionalOnClass found required class &apos;com.fasterxml.jackson.databind.ObjectMapper&apos;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) 12345678910Negative matches:----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes &apos;javax.jms.ConnectionFactory&apos;, &apos;org.apache.activemq.ActiveMQConnectionFactory&apos; (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes &apos;org.aspectj.lang.annotation.Aspect&apos;, &apos;org.aspectj.lang.reflect.Advice&apos;, &apos;org.aspectj.weaver.AnnotatedElement&apos; (OnClassCondition) 第三章 SpringBoot与日志 3.1 日志框架 System.out.println(“welcome!”); 不利于代码维护； 使用日志框架； 加入异步，自动归档等功能； 与程序耦合控制； 统一的接口层：日志门面。 常见的日志框架： JUL（java.util.logging）； JCL； jboss-logging； logback； log4j； log4j2； slf4j； 日志门面：SLF4J； 日志实现：Logback。 SpringBoot：底层是Spring框架，SpringBoot框架默认是JCL SpringBoot选用SLF4J，Logback。 3.2 SLF4J的使用 3.2.1 如何在系统中使用SLF4J开发的时候，日志记录的方法调用，应该直接调用日志抽象层里的方法，而不是日志的实现类。 给系统导入slf4j的jar和logback的实现jar： 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示： 每一个日志框架都有自己的配置文件，使用slf4j以后，配置文件还是作为日志实现框架本身的配置文件。 3.2.2 遗留问题a（slf4j + logback）：Spring(commons-logging)，Hibernate(jboss-logging) 统一日志记录，即便是别的框架也使用同一日志框架。 如何让系统中所有的日志都统一到slf4j： 将系统中其他日志框架排除在外； 用中间适配层包替换原有日志框架； 导入slf4j其他的实现。 3.3 SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot的日志功能： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; SpringBoot底层依赖关系（pom.xml文件，show diagram查看maven项目依赖关系）： SpringBoot底层也是用slf4j + logback的方式进行日志记录； SpringBoot也把其他的日志都替换成了slf4j； 中间替换包； 如果要引入其他框架，一定要把这个框架的默认日志依赖移除。 SpringBoot自动适应所有的日志框架，而且底层使用了slf4j + logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖移除掉。 3.4 SpringBoot默认日志配置日志的级别，由低到高，可以调整日志输出的级别： 1234567Logger logger = LoggerFactory.getLogger(getClass());//日志的级别，由低到高logger.trace("这是日志...");logger.debug("这是debug日志...");logger.info("这是Info信息...");logger.warn("这是警告...");logger.error("这是错误信息..."); SpringBoot默认日志输出级别为info。 可以在application.yml中自定义日志输出级别： logging.level.com.hape.nmsl=trace 在当前项目下生成日志文件：logging.file=springboot.log 不指定路径在项目路径下生成日志文件。 logfile优先级高于logpath。 logpath：指定日志文件的路径，默认文件名spring.log。 logging.pattern.console：控制台输出日志的格式。 logging.pattern.file：日志文件输出格式。 日志输出格式： 1234567891011%d：表示日期时间；%thread：表示线程号；%-5level：级别从左显示5个字符宽度；%logger&#123;50&#125;：表示logger名字最长50个字符，否则按照句点分割；%msg：日志信息；%n：换行符。 日志格式配置实例： 1%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n 3.5 指定日志文件和日志profile功能给类路径下放上每个日志框架自己配置文件即可， Because the standard logback.xml configuration file is loaded too early, you cannot use extensions in it. You need to either use logback-spring.xml or define a logging.config property. Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接被日志框架识别； logback-spring.xml：日志框架不直接加载配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级功能profile。 123456789101112可以指定某一段配置只在某个环境下生效&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt;&lt;/springProfile&gt;&lt;springProfile name="dev, staging"&gt; &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active--&gt;&lt;/springProfile&gt;&lt;springProfile name="!production"&gt; &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;&lt;/springProfile&gt; 3.6 切换日志框架可以按照slf4j适配图进行相关的切换。 排除不使用的包； 导入相关的适配包； 不推荐更换SpringBoot默认使用的日志记录框架。 第四章 SpringBoot与Web开发使用SpringBoot： 创建SpringBoot应用，选中需要的模块； SpringBoot自动配置好场景，需要在配置文件中指定少量配置，即可运行程序； 编写相关的业务逻辑。 依赖于SpringBoot的自动配置。 4.1 webjar与静态资源映射规则SpringBoot对静态资源的映射规则：（WebMvcAutoConfiguration.java） 1234567891011121314151617181920212223242526@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache() .getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration(registry .addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/") .setCachePeriod(getSeconds(cachePeriod)) .setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations( this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)) .setCacheControl(cacheControl)); &#125;&#125; 所有的/webjars/**，都到classpath:/META-INF/resources/webjars找资源； webjars以jar包的方式引入静态资源。 在访问的时候只需要写webjars下的资源名称即可。（http://localhost:8080/webjars/jquery/3.3.1-1/jquery.js） 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-1&lt;/version&gt;&lt;/dependency&gt; 访问当前项目下的任何资源（静态资源的文件夹） 1234"classpath:/META-INF/resources/", "classpath:/resources/","classpath:/static/","classpath:/public/" 配置欢迎页 12345678@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping( ApplicationContext applicationContext) &#123; return new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125; 静态文件夹下的所有index.html页面； 映射到 private String staticPathPattern = “/**”; 配置喜欢的图标 1234567891011@Configuration@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)public static class FaviconConfiguration implements ResourceLoaderAware &#123; private final ResourceProperties resourceProperties; private ResourceLoader resourceLoader; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; 映射到**favicon.ico静态资源文件夹。 4.2 引入Thymeleaf模板引擎 thymeleaf, jsp, freemaker, velocity SpringBoot推荐的thymeleaf： 引入thymeleaf； 自定义thymeleaf版本。 123&lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt;&lt;!--布局功能支持程序 thymeleaf3 layout2以上版本适配--&gt;&lt;thymeleaf.layout.dialect.version&gt;2.1.1&lt;/thymeleaf.layout.dialect.version&gt; 4.3 Thymeleaf语法默认请求路径：classpath:templates/xxx.html 文档地址：Thymeleaf参考文档 使用方法： 导入Thymeleaf名称空间； 1&lt;html lang="en" xmlns:th="http:y//www.thymeleaf.org"&gt; 使用Thymeleaf语法； 1&lt;div th:text="$&#123;hello&#125;"&gt;显示欢迎信息&lt;/div&gt; thymeleaf语法规则： th:text：改变text文本值； th:任意属性都可以替换； 文档第十章/Attributes/优先级； thymeleaf表达式； 123456789101112131415161718192021222324252627282930Simple expressions: Variable Expressions: $&#123;...&#125; Selection Variable Expressions: *&#123;...&#125; Message Expressions: #&#123;...&#125; Link URL Expressions: @&#123;...&#125; Fragment Expressions: ~&#123;...&#125;Literals Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,... Number literals: 0 , 34 , 3.0 , 12.3 ,... Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,...Text operations: String concatenation: + Literal substitutions: |The name is $&#123;name&#125;| Arithmetic operations: Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations: Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality: Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators: If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: Page 17 of 106No-Operation: _ 内置对象： 1234567#ctx : the context object.#vars: the context variables.#locale : the context locale.#request : (only in Web Contexts) the HttpServletRequest object.#response : (only in Web Contexts) the HttpServletResponse object.#session : (only in Web Contexts) the HttpSession object.#servletContext : (only in Web Contexts) the ServletContext object. 4.4 SpringMVC自动配置功能SpringBoot文档地址：官方文档地址 4.4.1 SpringMVC自动配置项SpringMVC自动配置： Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. Support for serving static resources, including support for WebJars (covered later in this document)). Automatic registration of Converter, GenericConverter, and Formatter beans. Support for HttpMessageConverters (covered later in this document). Automatic registration of MessageCodesResolver (covered later in this document). Static index.html support. Custom Favicon support (covered later in this document). Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). 123456789101112@Bean@ConditionalOnBean(ViewResolver.class)@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123; ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager( beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver uses all the other view resolvers to locate // a view so it should have a high precedence resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver;&#125; 123456789101112@Overridepublic void addFormatters(FormatterRegistry registry) &#123; for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123; registry.addConverter(converter); &#125; for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123; registry.addConverter(converter); &#125; for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123; registry.addFormatter(formatter); &#125;&#125; 12345@Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; this.messageConvertersProvider.ifAvailable((customConverters) -&gt; converters .addAll(customConverters.getConverters()));&#125; 如果用户有配置(@Bean，@Component)，则使用组合配置； 4.4.2 扩展SpringMVC配置添加一个配置类并且继承自WebMvcConfigurerAdapter。 将hello.do请求映射到hello.html视图： 123456789101112131415161718package com.web.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * @author zhulongkun20@163.com * @since 18-10-1 下午1:51 */@Configurationpublic class MvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// super.addViewControllers(registry); registry.addViewController("/hello.do").setViewName("/hello.html"); &#125;&#125; WebMvcAutoConfiguration是SpringMVC的自动配置类； 在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)。 123456@Autowired(required = false)public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125;&#125; 容器中所有的WebMvcConfiguration都会被调用。 所有的配置都会共同起作用。 4.4.3 全面接管SpringMVC在配置类中添加@EnableWebMvc：丢弃所有的自动配置，手动配置所有的配置。 原理： WebMvc： 123456@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125; DelegatingWebMvcConfiguration： 1234@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();&#125; WebMvcAutoConfiguration： 12345678@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)//容器中缺少此组件，该自动配置生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;) 4.5 引入资源SpringBoot中使用webjars引入jquery和bootstrap之类的资源： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;index&lt;/title&gt; &lt;link rel="stylesheet" th:href="@&#123;webjars/bootstrap/4.1.3/css/bootstrap.css&#125;" th:type="text/css"/&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 即使更换项目访问名也可以正常加载静态资源。 1234567891011121314151617181920212223242526272829package com.web.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * @author zhulongkun20@163.com * @since 18-10-1 下午1:51 *///@EnableWebMvc@Configurationpublic class MvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// super.addViewControllers(registry); registry.addViewController("/hello.do").setViewName("/hello.html"); registry.addViewController("/").setViewName("/hello.html"); &#125; public WebMvcConfigurerAdapter webMvcConfigurerAdapter() &#123; return new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("/hello.html"); &#125; &#125;; &#125;&#125; 4.6 国际化 编写国际化配置文件； 使用ResourceBundleMessageSource管理国际化资源文件； 在页面使用fmt:message取出国际化内容。 配置如下图： SpringBoot自动配置（MessageSourceAutoConfiguration.java）： 12345678910111213141516171819202122232425262728@Bean//类路径下配置文件spring.messages@ConfigurationProperties(prefix = "spring.messages")public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties();&#125;@Beanpublic MessageSource messageSource() &#123; MessageSourceProperties properties = messageSourceProperties(); ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; //设置国际化资源文件的基础名（去除国际语言代码） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource;&#125; 设置配置文件地址： 1spring.message=login 页面中获取国际化资源： 1234&lt;lable class="sr-only" th:message="#&#123;login.tip&#125;"&gt;Tips&lt;/lable&gt;&lt;lable class="sr-only" th:message="#&#123;login.username&#125;"&gt;Username&lt;/lable&gt;&lt;lable class="sr-only" th:message="#&#123;login.password&#125;"&gt;Password&lt;/lable&gt;&lt;lable class="sr-only" th:message="#&#123;login.remember&#125;"&gt;remember&lt;/lable&gt; 浏览器根据浏览器语言设置的信息自动切换国际化。 SpringMVC区域信息组件： 12345678910111213@Bean@ConditionalOnMissingBean@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125;//默认根据请求头获取的区域信息展示国际化信息。 可以在请求参数上携带区域信息实现国际化： 12https://localhost:8080/hello.do?language=zh_CNhttps://localhost:8080/hello.do?language=en_US 手动配置区域信息解析器： 12345678910111213141516171819202122232425262728293031323334package com.web.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.thymeleaf.util.StringUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;/** * @author zhulongkun20@163.com * @since 18-10-3 下午4:43 */@Configurationpublic class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String language = httpServletRequest.getParameter("language"); Locale locale = Locale.getDefault(); if (!StringUtils.isEmpty(language)) &#123; String[] regionInfo = language.split("_"); locale = new Locale(regionInfo[0], regionInfo[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 4.7 拦截器 PostMapping()：RestfulAPI注解； 开发期间禁用Thymeleaf的缓存：spring.thymeleaf.cache=false； 错误消息的显示； 防止表单重复提交，添加视图视图映射后，使用重定向。 使用拦截器进行身份校验； 编写拦截器，在配置类中注册拦截器。 页面中使用Thymeleaf获取值。 4.8 CRUD实验4.8.1 实验要求实验要求： RestfulAPI风格： URI：/资源名称/资源标识； HTTP请求方式区分对资源的CRUD操作； 操作 普通CRUD RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xxx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 实验的请求架构： 请求URI 请求方式 查询所有的员工 emps GET 查询某个员工 emp/{id} GET 来到添加界面 emp GET 添加员工 emp POST 来到修改界面 emp/{id} PUT 修改员工 emp PUT 删除员工 emp/{id} DELETE 4.8.2 公共页面抽取—列表页 利用Thymeleaf抽取公共页面； 12345678&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;body&gt;&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; “~{templatename::selector}”：模板名选择器； ~{templatename::fragmentname}：模板名：片断名。 默认效果： insert片段都在div标签中 1234&lt;body&gt;...&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;/body&gt; 三种引入功能片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中； th:replace：将声明引入的元素替换为公共片段； th:include：将被引入的片段的内容包含进这个标签中。 4.8.3 链接高亮&amp;列表完成 实现方法：引入公共片段时传入相关参数，公共片段根据参数高亮相关部分。 Thymeleaf日期工具对象(文档附录 &gt; dates)： 1#dates : methods for java.util.Date objects: formatting, component extraction, etc. 1234$&#123;#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125; 4.8.4 添加员工 &gt; 来到添加页面 添加表单：Bootstrap官网模板直接复制； 通过 *添加 *按钮跳转到添加页面； 使用th:each完成部门的遍历； 4.8.5 添加员工 &gt; 完成添加 完成添加后 重定向 至列表页面（forward或者redirect）； 提交的数据格式问题：日期格式： 日期格式化：SpringMVC将页面提交的值需要转换成指定的类型； 在配置文件中自定义表单提交的日期格式。 4.8.6 修改员工信息 配置HiddenHttpMethodFilter； 4.8.7 删除员工 4.9 定制错误页面 默认出错处理：返回一个默认的错误处理页面：在页面共享信息； 如果是其他客户端，默认响应一个json数据； 可以参照ErrorAutoConfiguration，错误处理的自动配置，在容器中添加如下组件： DefaultErrorAttributes； BasicErrorController：处理默认的error错误请求； 12345678910@RequestMapping(produces = "text/html")public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView("error", model);&#125; ErrorPageCustomizer：系统出现错误，来到/error请求进行处理：web.xml； DefaultErrorViewResolver； 1234567891011121314151617181920212223242526static &#123; Map&lt;Series, String&gt; views = new EnumMap&lt;&gt;(Series.class); views.put(Series.CLIENT_ERROR, "4xx"); views.put(Series.SERVER_ERROR, "5xx"); SERIES_VIEWS = Collections.unmodifiableMap(views);&#125;@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125;private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; String errorViewName = "error/" + viewName; TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; return new ModelAndView(errorViewName, model); &#125; return resolveResource(errorViewName, model);&#125; 定制自定义错误页面： 有模板引擎的情况下：error/状态码，将错误命名为status_code.html放在classpath:error/下，发生此错误会来到该页面； 可以使用4xx和5xx作为错误页面的文件名来匹配该类型的所有错误，精确匹配优先； 页面能获取的信息： timestamp； message； status code； exception； errors。 没有模板引擎：静态资源文件夹下寻找。 定制自定义json数据： 没有自适应效果，浏览器和客户端返回的都是json数据： 123@ControllerAdvice@ExceptionHandler@Response 自适应效果：转发给/error进行自适应效果处理，给request中传入自己的参数： 12345678910111213141516171819@RequestMapping(produces = "text/html")public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView("error", model);&#125;@RequestMapping@ResponseBodypublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;&gt;(body, status);&#125; 将自定义错误信息携带： 响应数据由getErrorAttributes()获取： 编写一个ErrorController的实现类或者AbstractErrorController的子类，放在容器中； 页面上能用的数据或者json返回的数据都是errorAttributes.getErrorAttributes得到；DefaultErrorAttributes.getErrorAttributes()进行错误处理。 123456789101112131415161718192021package com.web.config;import org.springframework.boot.web.servlet.error.DefaultErrorAttributes;import org.springframework.stereotype.Component;import java.util.Map;/** * @author zhulongkun20@163.com * @since 18-10-7 下午4:25 */@Componentpublic class MyErrorHandler extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes( org.springframework.web.reactive.function.server.ServerRequest request, boolean includeStackTrace) &#123; return super.getErrorAttributes(request, includeStackTrace); &#125;&#125; 第五章 配置嵌入式Servlet容器 5.1 定制嵌入式Servlet容器默认使用嵌入式tomcat8.5.4作为嵌入式的Servlet容器； 如何定制嵌入式的Servlet容器？ SpringBoot能否支持其他的Servlet容器？ 修改和Server有关的配置(server.properties)： 12server.port=8080servet.context-path=/path 编写一个EmbeddedServletContainerCustomizer来修改嵌入式Servlet容器： 123456@Beanpublic EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer() &#123; public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125;&#125; 与容器相关的类：ServerProperties.class SpringBoot2.0： 12345678@Componentpublic class EmbeddedTomcatConfig implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123; @Override public void customize(ConfigurableServletWebServerFactory factory) &#123; factory.setContextPath("/test"); &#125;&#125; 5.2 注册Servlet容器三大组件Servlet：ServletRegistrationBean 1234@Beanpublic ServletRegistrationBean&lt;MyServlet&gt; myServlet() &#123; return new ServletRegistrationBean&lt;&gt;(new MyServlet(), "/servlet.do");&#125; Filter：FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean&lt;MyFilter&gt; myFilter() &#123; FilterRegistrationBean&lt;MyFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello.do", "/nihao.do")); return registrationBean;&#125; Listener：ServletListenerRegistrationBean 123456@Beanpublic ServletListenerRegistrationBean&lt;MyListener&gt; myListener() &#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;MyListener&gt;(); registrationBean.setListener(new MyListener()); return registrationBean;&#125; 5.3 嵌入式Servlet容器自动配置原理EmbeddedWebServerFactoryCustomizerAutoConfiguration.class Tomcat： 12345678910@Configuration@ConditionalOnClass(&#123; Tomcat.class, UpgradeProtocol.class &#125;)public static class TomcatWebServerFactoryCustomizerConfiguration &#123; @Bean public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer( Environment environment, ServerProperties serverProperties) &#123; return new TomcatWebServerFactoryCustomizer(environment, serverProperties); &#125;&#125; Jetty： 1234567891011@Configuration@ConditionalOnClass(&#123; Server.class, Loader.class, WebAppContext.class &#125;)public static class JettyWebServerFactoryCustomizerConfiguration &#123; @Bean public JettyWebServerFactoryCustomizer jettyWebServerFactoryCustomizer( Environment environment, ServerProperties serverProperties) &#123; return new JettyWebServerFactoryCustomizer(environment, serverProperties); &#125;&#125; Undertow： 1234567891011@Configuration@ConditionalOnClass(&#123; Undertow.class, SslClientAuthMode.class &#125;)public static class UndertowWebServerFactoryCustomizerConfiguration &#123; @Bean public UndertowWebServerFactoryCustomizer undertowWebServerFactoryCustomizer( Environment environment, ServerProperties serverProperties) &#123; return new UndertowWebServerFactoryCustomizer(environment, serverProperties); &#125;&#125; 配置文件：Server.properties： 12@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)public class ServerProperties &#123; ConfigurableTomcatWebServerFactory.class： 5.4 使用外置的Servlet容器内置的servlet容器不支持jsp； 向项目中导入tomcat服务器，创建web.xml文件，添加application.properties配置；打包方式为war包； 必须编写一个ServletInitializer文件； 123456public class ServletInitializer extends SpringBootServletInitializer &#123; @override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources($&#123;MainClass&#125;.class); &#125;&#125; 将嵌入式spring-boot-start-web内嵌的tomcat的scope指定为provided； 第六章 Docker技术6.1 docker简介概念：Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 Docker入门 6.2 Docker核心概念 docker主机(Host)：安装了Docker程序的机器(Docker直接安装在操作系统之上)； docker客户端(Client)：连接Docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像，放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器，容器是独立运行的一个或一组应用； 使用docker容器的步骤： 安装docker； 去docker仓库找到这个软件对应的镜像； 使用docker运行这个镜像，就会生成一个Docker镜像容器； 对容器的启动和停止就是对软件的启动和停止。 6.3 Docker常用操作镜像官方网站：Docker Hub 1234docker search mysql //搜索镜像docker pull mysql:5.5 //拉取镜像docker images //查看本地所有镜像docker rmi images-id //删除本地镜像 各个独立的容器互不干扰，独立运行。 6.4 环境搭建6.4.1 安装MySQL：启动一个MySQL实例(需要指定密码和端口映射)： 1$ docker run -p port --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 官方文档：MySQL文档 几个高级操作： 12345使用配置文件：$ docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag不适用配置文件：$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 6.4.2 安装Redis6.4.3 安装RabbitMQ6.4.4 安装ElasticSearch 第七章 SpringBoot与数据库访问SpringBoot与数据访问相关的场景启动器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283spring-boot-starter-data-cassandraStarter for using Cassandra distributed database and Spring Data CassandraPomspring-boot-starter-data-cassandra-reactiveStarter for using Cassandra distributed database and Spring Data Cassandra ReactivePomspring-boot-starter-data-couchbaseStarter for using Couchbase document-oriented database and Spring Data CouchbasePomspring-boot-starter-data-couchbase-reactiveStarter for using Couchbase document-oriented database and Spring Data Couchbase ReactivePomspring-boot-starter-data-elasticsearchStarter for using Elasticsearch search and analytics engine and Spring Data ElasticsearchPomspring-boot-starter-data-jpaStarter for using Spring Data JPA with HibernatePomspring-boot-starter-data-ldapStarter for using Spring Data LDAPPomspring-boot-starter-data-mongodbStarter for using MongoDB document-oriented database and Spring Data MongoDBPomspring-boot-starter-data-mongodb-reactiveStarter for using MongoDB document-oriented database and Spring Data MongoDB ReactivePomspring-boot-starter-data-neo4jStarter for using Neo4j graph database and Spring Data Neo4jPomspring-boot-starter-data-redisStarter for using Redis key-value data store with Spring Data Redis and the Lettuce clientPomspring-boot-starter-data-redis-reactiveStarter for using Redis key-value data store with Spring Data Redis reactive and the Lettuce clientPomspring-boot-starter-data-restStarter for exposing Spring Data repositories over REST using Spring Data RESTPomspring-boot-starter-data-solrStarter for using the Apache Solr search platform with Spring Data SolrPom 7.1 整合JDBC与数据源建表语句执行：classpath:schema-*.sql 数据操作语句：classpath:data-*.sql 也可以使用schema在application.yml中自定义数据文件地址。 7.2 Druid数据源配置 引入依赖； 配置属性。 1type指定数据源 添加一个配置类，将Druid配置映射到数据源。 结合过滤器和Servlet设置Druid监控。 7.3 整合MyBatis启动器： 1mybatis-spring-boot-starter 获取插入数据库的记录的ID： @Options(userGeneratedKeys=, keyProperty=） 开启MyBatis驼峰命名： 写一个配置类，实现ConfigurationCustomizer接口中的customize()方法： 1configuration.setMapUnderscopeToCamelCase(true); 批量扫描所有的@Mapper注解： @MapperScan(value=””) 相关配置文件见官网文档。 全局配置文件配置： 12mybatis-config-location:classpath:mybatis/config.xmlmybatis-config-mapper:class:mybatis/mapper.xml 7.4 SpringData数据访问JPA]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末随想]]></title>
    <url>%2F2018%2F12%2F31%2F%E5%91%A8%E6%9C%AB%E9%9A%8F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[我们对于时间流逝的恐惧，不在于年龄增长带来的容颜衰老，而是光阴逝去，我们仍然一无所得。 似乎从17年下半年实习完回到学校之后，时间就走得越来越快，平日里忙忙碌碌，稍有空闲偶然抬头，夕阳已在靠近山头。不知是我自己的错觉，还是周围的人也有同样的感觉。 工作近半年，我的潜意识似乎还停在六七月份，提着行李刚刚踏出校门的时候，尽管每天走出家门越来越冷的天气都会提醒我18年已然所剩无几。终于，18年就要过去了，我应该会从这仿佛停滞的潜意识中走出来吧。 早上下楼，在花池边上看到的一颗爱心，趁还没被雪覆盖之前，拍了下来。 元旦假期刚好碰上了周末，新的一年应该算是一个重新振作、重新迈出脚步的好时机，对于我这样一段时间就会心血来潮把所有物品重新收拾一遍的人来说，这个周末可以说是一个一年一遇的好机会了。 周六早上还是照旧睡了个懒觉，起来吃个饭已经三点钟了。阳光明媚寒风凛冽的冬天自然是不适合出门的，下午就在网上冲浪，几个小时过得还算快。逛了会儿贴吧（因为发了句“苟利国家生死以”号被永封了，现在的社交媒体还是心理太敏感。） 晚上才意识到这就是年末了，其实我以为是周六是31号，就把家里彻彻底底收拾了一遍，收拾完已经是十二点了。又翻出了很多以前的东西，实习时候的、支教时候的、从大一到大四平时收集的纪念品（我有收藏的习惯，虽然只是一张草稿纸，也能让我在多年以后仍能回忆起N年前的那一刻的处境和想法。） 今天晚上又在这本工数二里翻出了不少回忆。其实早已经忘了里面的内容。 好像大多数学生对我的评价都是善良、温柔、帅。。 虽然两年多过去了，依然清晰的记得对她的印象，上课捣蛋，不听话，其实并不是她的本性就是这样，她只是想用一些极端的方式引起别人对她的注意。后来，她生病了，她所说的“关心”大概就是每次上课之前我都问问她的病情，记得在送别会上哭了很长时间。 这也太真实了吧，矮我也就认了，这是我第一次听到有人说我丑的，小小年纪就懂得先抑后扬，将来可能会成为大文豪。 这大概是16年冬天的时候去厦门，路过上海，特意去体验了上海磁浮。坐在飞驰的列车里，看着窗外高速公路上仿佛停止的车流，英语老师讲课的场景又在脑海中浮现出来。外研版英语教材中有一个单元的主题就是上海磁悬浮列车。黑板上的屏幕里放着老师当年在磁浮列车中拍摄的视频，窗外也是阳光明媚，屏幕里的高速公路和此刻我眼中所见别无二样，一闪而过、飞一般后退的风景，给人一种莫名的安心。曾经盼不到下课的45分钟在此刻却是如此短暂，只是此刻耳边响起的不再是熟悉动听的下课铃声，而是从未听到过的到站提醒。 至今让然保存着一次英语四级、三次英语六级、一次日语N2、一次日语N1考试的准考证。英语四级455、六级第一次375、第二次404、第三次530，日语N2 125、N1 108。总算是有心人，天不负吧。 这是大二的时候去参加学校的“爱心包裹”募捐活动，那也是一个冬天，因为起得比较晚，没吃早饭没吃中午饭便去了开发区安盛广场。冒着寒风，厚着脸皮，从两点到四点半，和隔壁班搭档两个人募到了600，没有人比我们更高了，当时给我们开心得不行，在冒着小雨去管委会集合的路上，遇到一个撑伞的老奶奶，给我捐了100，还给我了一个翻墙工具光盘，让我们去了解法轮功真相。去邮政寄完钱，回到软院，终于在食堂吃上了第一顿饭，特意加了个鸡蛋奖励自己。满足的心情，至今记忆犹新。 大一时候的院运动会，参加了5公里长跑，14113号；大二时候的院运动会，参加了跳远，14116号。身边都是人高马大的，自卑了。。 合唱内容早已忘却，停在山上礼堂门口的那辆车却依然能清晰的记起来，“红旗”，一直觉得这个名字很响亮。 16年12月沪昆高铁贵昆段开通，特意在贵阳转车，去体验经过家乡的高铁。第一次坐高铁，贵阳到家从四个小时缩短到一个小时，速度很快。16年底县里刚刚改名，从“盘县”改名到“盘州市”，所以每次看到这个“盘州站”，总给我一种陌生的感觉。贵阳北站的检票工具是一个💗（心）型，拍照的时候我特意在下面加了红色背景。从远方回家过年的人，看到车票上的这个爱心，应该会有一种温暖和感动的感觉吧，至少我是这样的。 把所有的车票集到一起才发现，原来坐着火车也去过不少地方呢。最常去的城市是六盘水、北京和大连；到过贵阳、厦门、三明、上海、西安、南昌、石家庄、烟台、郑州、北京、西安、广州、南宁、鞍山。 北京房东奶奶送我的咖啡和糖、支教学生们的给我的联系方式和信件、嘉年华消费券…以前总是无意间就将想永久珍藏的东西放到这个保鲜盒中，渐渐地成为了习惯；后来我常常在想，食物放到保鲜盒中就能保持新鲜，那回忆呢，放到保鲜盒中也能永远保持新鲜吗？ 一直记得去年的动漫《少女终末旅行》中有一句令人印象深刻的台词：記憶なんて、生きるの邪魔しかない（我将其翻译为：回忆，不过是生活的绊脚石）。如果你总是往后看，那会走得缓慢，把过去都藏到角落里，生活该大步的往前走，回忆，只适合在某个无所事事阴雨绵绵的晚上，翻出来打发时间。 收拾东西，想把硬币都擦一擦，因为太重，盒子裂开了，硬币洒了一地。 把桌子上的东西都擦了一遍。 把桌子上的东西都擦了一遍，给绿萝也擦了叶子。 周天和学弟打了一下午的台球，一起吃了顿饭。晚上回来取到了相机。以后周末能多出去转转了，在这座城市生活了四年，却没去过几个地方，很是惭愧。 出差两个月的室友今天晚上回来了，带了一些日本的零食。 坚持减肥十二天了，争取在春节之前减到100。 不知不觉写了一个小时，也该睡觉了，明天还要上班，明天就是18年最后一天了，该好好想想怎么跨年了。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《徒步中国》]]></title>
    <url>%2F2018%2F12%2F09%2F%E3%80%8A%E5%BE%92%E6%AD%A5%E4%B8%AD%E5%9B%BD%E3%80%8B%2F</url>
    <content type="text"><![CDATA[一年半以后，我终于读完了这本书。 最初是去年的五月份在图书馆寻找旅行和摄影相关的书时，看到了这本书，书的名字——徒步中国，一下就吸引了我。960万平方公里辽阔的土地，我想许多热爱旅行的人都想走遍她的每一个角落，从江南水乡到青藏高原、从西沙群岛再到冰天雪地的黑龙江。 一直对这种第一人称出场人数少流水账式的书很有好感，可以快读，可以慢读，甚至能跳着读，不需要过多的去思考这句话背后的其他含义，不需要记住太多的设定，只要知道什么时间在什么地方遇到了什么事就足够了。 4646KM，我对这个数字已经没有过于清晰的概念了，只记得初中地理书上“中国的最东边在乌苏里江与黑龙江交汇处，最西边帕米尔高原，东西相距5200KM。”这样的类似的描述了；不过较为清晰的是107国道从北京广安门外到深圳北环大道有2700KM，如果哪一天我突然也想出去走走，那107国道将会是我第一个目标。 一个留学生能在中国徒步这么长的距离，每次拿起书本我的心中满是钦佩之情，一年的时间，几乎都在路上，一个人，不停的走路，还需要带着行李，几乎没有可以说话的地方，这需要相当的经济支撑，也需要相当大的勇气和毅力。但是每到达一个城市、每经过一千公里时的喜悦，却是容易体会的，在到达一个个小终点的喜悦面前，所有的一切都是值得的。 很多人问：你不觉得孤独吗？其实他也回答不上来，但是他觉得去经历这个过程很好。 到达每一座城市都是一个全新的开始，可以去亲身感受每一座城市独特之处，和这座城市的人交流，品尝这座城市的美食，游览这座城市的景点，用相机记录下这座城市的美，这就是旅行的意义吧。如果一生中能多有几次这样的经历，也算是美好的回忆了。 我又想起自己那份已经落满厚厚一层灰的107计划，我的内心也是一个喜欢四处游走、不停的记录的人，从广安门外到深圳北环大道，我无数次在地图上标注起点终点，然后放大缩小，甚至已经计划好了每一天的行程，整整30天，但是众所周知走出第一步总是最困难的。随着年龄的增长，只会越来越困难，我甚至做好了放弃的准备。 每每看到其他人博客里贴出来的林间小道，骑行头盔和公路车，心里总有无尽的羡慕，能说走就走的人，才是真正热爱生活的人。他们的才叫生活，而我经历的，叫生存或许来得更贴切一些。 一直从贯穿全书的还有作者和女朋友的分分合合。一个是在中国徒步的德国人，一个是在德国留学的中国人，总给人冥冥之中早已注定的感觉。全书的结尾，两人还是分手了。我不是一个相信爱情的人，更别提异地恋和异国恋了。女生终究需要的是陪伴，是看得见摸得着的安全感，千里相隔，即便千言万语也无济于事。一边是深爱的人，一边是自己的原则和理想，仿佛就是一般爱情电影里狗血剧情。书中还有一句话：每一个人在世界上都有20万个适合做伴侣的人。虽然我一直认为感情的事情绝大多数时候都是自寻烦恼，但是我的内心对于爱情还是期待的，尽管我不相信世界上会有所谓的知己存在。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>《徒步中国》</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深田恭子的日剧跑]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B7%B1%E7%94%B0%E6%81%AD%E5%AD%90%E7%9A%84%E6%97%A5%E5%89%A7%E8%B7%91%2F</url>
    <content type="text"><![CDATA[深田恭子的日剧跑—Bilibili]]></content>
      <categories>
        <category>V</category>
      </categories>
      <tags>
        <tag>V</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo学习笔记]]></title>
    <url>%2F2018%2F12%2F02%2Fdubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[dubbo学习笔记 dubbo中文官方网站 dubbo官方文档 分布式系统及其演变历程 单一应用架构： 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 垂直应用架构： 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构： 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构： 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 RPCRPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 远程过程调用：序列化和网络通信。 特性一览 面向接口代理的高性能RPC调用 智能负载均衡 服务自动注册与发现 高度可扩展能力 运行期流量调度 可视化的服务治理与运维 dubbo应用架构 dubbo快速启动dubbo快速启动 dubbo实例1234567891011121314151617181920212223242526272829303132333435363738package bean;import java.io.Serializable;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:45 */public class UserAddress implements Serializable &#123; private Integer id; private String userId; private String userAddress; private String consignee; private String phoneNum; private boolean isDefault; public UserAddress(Integer id, String userId, String userAddress, String consignee, String phoneNum, boolean isDefault) &#123; this.id = id; this.userId = userId; this.userAddress = userAddress; this.consignee = consignee; this.phoneNum = phoneNum; this.isDefault = isDefault; &#125; @Override public String toString() &#123; return "UserAddress&#123;" + "id=" + id + ", userId='" + userId + '\'' + ", userAddress='" + userAddress + '\'' + ", consignee='" + consignee + '\'' + ", phoneNum='" + phoneNum + '\'' + ", isDefault=" + isDefault + '&#125;'; &#125;&#125; 123456789package service;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:46 */public interface OrderService &#123; String initOrder(String userId);&#125; 12345678910111213package service;import bean.UserAddress;import java.util.List;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:46 */public interface UserService &#123; List&lt;UserAddress&gt; getUserAddressList(String userId);&#125; 1234567891011121314151617181920212223package service.impl;import bean.UserAddress;import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;import service.UserService;import java.util.Arrays;import java.util.List;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午7:49 */@Service@Componentpublic class UserServiceImpl implements UserService &#123; public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; UserAddress userAddress1 = new UserAddress(1, "001", "人民广场", "100", "230189", true); UserAddress userAddress2 = new UserAddress(2, "002", "文化公园", "101", "230190", false); return Arrays.asList(userAddress1, userAddress2); &#125;&#125; 123456789101112131415161718package com.dubbo.service.consumer.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午8:43 */@Servicepublic class OrderServiceImpl implements OrderService &#123; @Autowired private UserService userService; public String initOrder(String userId) &#123; return userService.getUserAddressList(userId); &#125;&#125; 1234567891011121314151617181920212223package com.dubbo.service.consumer.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;/** * @author zhulongkun20@163.com * @since 2018/12/2 下午9:00 */@Controllerpublic class OrderController &#123; @Autowired private OrderService orderService; @ResponseBody @RequestMapping("/initOrder.do") public String initOrder(@RequestParam("userId") String userId) &#123; return orderService.initOrder(userId); &#125;&#125; 12345678910111213package com.dubbo.service.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableDubbo@SpringBootApplicationpublic class DubboDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboDemoApplication.class, args); &#125;&#125; 123456789101112131415161718192021# Spring boot applicationspring.application.name = dubbo-provider-demoserver.port = 9090management.port = 9091# Base packages to scan Dubbo Components (e.g., @Service, @Reference)dubbo.scan.basePackages = com.alibaba.boot.dubbo.demo.provider.service# Dubbo Config properties## ApplicationConfig Beandubbo.application.id = dubbo-provider-demodubbo.application.name = dubbo-provider-demo## ProtocolConfig Beandubbo.protocol.id = dubbodubbo.protocol.name = dubbodubbo.protocol.port = 12345## RegistryConfig Beandubbo.registry.id = my-registrydubbo.registry.address = N/A]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>dubbo</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活小记]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%84%89%E5%BF%AB%E7%9A%84%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[因为项目延期，并且已经到了项目后期，所以工作也是越来越忙，忙起来，自然就没有多余的时间去胡思乱想，自然而然时间也过得快了，每天到公司开始干活，感觉累了抬头一看，窗外已是漆黑一片，周末的到来也是同样的令人不可思议。 今天周六，也是十二月一号，新的一个月的开始。 因为今天是周末，昨天晚上睡得并不算早，但是却是意外的起了个大早。起点便醒来，感觉眼睛有点疼又接着睡了一会儿，拿起手机看看才八点多一点，碰巧拿起手机便接到了快递的电话，突然我很后悔自己不让快递把快递送蜂巢，但是也觉着早起也挺好的，反正也不觉得困了。感觉自己很奇怪，平时上班早上八点多起床还觉得困，能睡的时候却早早的醒了。 洗漱完毕，取了快递，立马拆开读了半小时，昨天晚上买的书《百年孤独》，周三和学妹一起吃饭时提到了她在读这本书。昨天晚上下班回来约了学妹下午出去玩。这两天一直在听《轻音少女》的插曲《ふわふわ時間》，一直听到十一点半，然后去本部找学妹。 先去了星海公园海边，拍了几张照片，天气不算太差，风也不是很大。 然后去了喜家德喝了点东西，本来打算去市内的，下车了才发现两人说的不是一个地方。。阴差阳错的去了和平广场，逛了无印良品、华润超市、数码书店还去买了香薰，吃了火锅。 简直不敢相信竟然逛了大半天，这算是我第一次逛商场吧，和学妹逛商场还挺有意思的，虽然有点小累，了解到了很多之前没听说过的东西。 快乐的时光总是短暂。离开商场的时候，学妹说在我生日的时候给送我香水作为生日礼物，有一瞬间觉得特别开心，但是接踵而至的却是负面的情绪。聚少离多在生活中更加常见，此时此刻，能轻松的许下诺言，可是谁又能知道明年的今天，彼此是不是早已天各一方？不论以后如何，只觉得要珍惜眼前。 （这破图怎么旋转了，在七牛云里明明好好的。。） 和学妹开心的一天。]]></content>
      <categories>
        <category>随便写写</category>
      </categories>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记-第三章-高级装配]]></title>
    <url>%2F2018%2F11%2F24%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[第三章：高级装配 本章内容： Spring profile 条件化的bean声明 自动装配与歧义性 bean的作用域 Spring表达式语言 3.1 环境与profile在软件开发的不同阶段需要不同的环境和配置。 1234567@Bean(destroyMethod = "shutdown")public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .addScript("classpath:ch3.sql") .addScript("classpath:ch3.1.sql") .build();&#125; 为了适应环境更换的需求，可以将所需要的所有的配置类配置到每个bean中，然后在构建阶段选择需要使用的bean，但是从开发环境切换到生产环境时可能会发生问题。 3.1.1 配置profile beanSpring为此种场景提供了profile功能。 使用profile注解来声明在合适的阶段使用合适的bean。将所有的bean整理到一个profile中，确保在需要的时候active相应的bean。 1234567891011121314151617181920212223242526272829303132333435363738package com.ch3;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;import org.springframework.jndi.JndiObjectFactoryBean;import javax.sql.DataSource;/** * @author zhulongkun20@163.com * @since 2018/11/24 下午1:00 */@Configurationpublic class DataSourceConfig &#123; @Bean(destroyMethod = "shutdown") @Profile("dev") public DataSource embeddedDataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:test.sql") .addScript("classpath:test1.sql") .build(); &#125; @Bean @Profile("prod") public DataSource jndiDataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jndi/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125;&#125; 虽然所有的bean都被声明在一个profile里，但是只有当指定的profile被激活时，相应的bean才会被创建，没有指定profile的bean始终都会被创建，与激活的profile没有关系。 在XML中配置profile： 可以通过beans元素的profile属性，在xml中配置profile。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd" profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource"&gt; &lt;jdbc:script location="classpath:test.sql"/&gt; &lt;jdbc:script location="classpath:test1.sql"/&gt; &lt;/jdbc:embedded-database&gt;&lt;/beans&gt; 只有profile属性与当前激活的profile相匹配的配置文件才会被用到。 重复使用beans属性指定多个profile： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:jee="http://www.springframework.org/schema/jee" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd"&gt; &lt;beans profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource"&gt; &lt;jdbc:script location="classpath:test.sql"/&gt; &lt;jdbc:script location="classpath:test1.sql"/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile="prod"&gt; &lt;jee:jndi-lookup jndi-name="jdbc/MyDatabase" id="dataSource" resource-ref="true" proxy-interface="javax.sql.DataSource"/&gt; &lt;/beans&gt;&lt;/beans&gt; 虽然id都一样，类型都是javax.sql.dataSource，但是只会创建指定profile的bean。 3.1.2 激活profileSpring在确定处于激活状态的profile时，依赖于两个独立的属性： spring.profiles.active spring.profiles.default 优先级从上到下，如果spring.profiles.active没有设置，则看spring.profiles.default，否则只会创建没有定义在profiles中的bean。 有多种方式设置这两个属性： 作为DispatcherServlet的初始化参数 作为web应用的上下文参数 作为JNDI条目 作为环境变量 作为JVM属性 在集成测试类上使用@ActiveProfiles属性 在web.xml配置文件中设置默认的profile： 1234567891011121314&lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 可以同时激活多个profile，以逗号分隔。 使用profile进行测试： Spring提供了@ActiveProfiles注解，用来指定测试时使用的profile。 123456@RunWith(SpringJunit4ClassRunner.class)@ContextConfiguration(classes=&#123;PersistenceTestConfig.class&#125;)@ActiveProfiles("dev")public class PersistenceTest &#123; &#125; 3.2 条件化的bean需求： 希望一个或多个bean只有在类路径下包含某个特定的库时才创建 希望某个bean在特定的bean声明之后再创建 Spring 4引入了@Conditional注解，只有条件计算结果为true才会创建bean，否则不创建。 123456789101112131415161718package com.ch3;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;/** * @author zhulongkun20@163.com * @since 2018/11/24 下午2:07 */public class MagicExistsCondition implements Condition &#123; @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment environment = conditionContext.getEnvironment(); return environment.containsProperty("magic"); &#125;&#125; 12345@Bean@Conditional(MagicExistsCondition.class) //条件化创建beanpublic MagicBean magicBean() &#123; return new MagicBean();&#125; ConditionContext接口： 1234567891011public interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); ClassLoader getClassLoader();&#125; getRegistry：根据返回值可以检查bean定义 getEnvirnment：检查环境变量 getResourceLoader：读取加载的资源 getClassLoader：加载并检查类是否存在 AnnotatedTypeMetadata接口： 1234567891011public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String var1); Map&lt;String, Object&gt; getAnnotationAttributes(String var1); Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125; 3.3 处理启动装配的歧义性仅有一个bean匹配所需结果时，自动装配才是有效的，如果有多个bean能够匹配结果的话，这种歧义性会阻碍Spring自动装配属性、构造器参数和方法参数。 Spring提供的解决方案： 将可选bean中的其中一个声明为首选（primary） 使用限定符（qualifier）缩小可选范围 3.3.1 标示首选的bean将其中一个可选的bean声明为首选可以避免自动装配的歧义性。 12345678910111213141516@Autowiredpublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125;@Component@Primarypublic class IceCream implements Dessert &#123; //...&#125;@Bean@Primarypublic Dessert dessert() &#123; return new IceCream();&#125; xml配置： 1&lt;bean id="iceCream" class="com.test.dessert.IceCream" primary="true"/&gt; 3.3.2 限定自动装配的bean设置首选bean的局限性在于 @Primary无法将可选方案范围限定到一个无歧义性的选项中 ，当首选bean的数量超过一个时，无法进一步缩小限定范围。 @Qualifier注解是使用限定符的主要方式，与@Autowired协同使用，在注入时指定要注入的bean。 12345@Autowired@Qualifier("iceCream")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; @Qualifier注解的参数就是想要注入的bean的id，所有使用@Component注解的类都会创建为bean，且id为首字母小写的类名。 基于默认id作为限定符是简单的，但是当类名被更改之后会使限定符失效。 创建自定义的限定符： 可以设置自己的限定符，而不依赖于bean id作为限定符。 12345@Component@Qualifier("cold")public class IceCream implements Dessert &#123; &#125; 此时cold限定符分配给了IceCream bean，只需要在合适的地方引入cold限定符即可自动装配。 12345@Bean@Qualifier("cold")public Dessert iceCream() &#123; return new IceCream();&#125; 此时类限定名的变更不会影响到自动装配。但是当应用中出现同名的注解@Qualifier(“cold”)时，歧义性又会再次出现。 这时需要多个@Qualifier注解来进一步缩小限定范围。 3.4 bean的作用域默认情况下，Spring应用上下文中的所有bean都是以单例模式创建的。不管给定的bean被注入到其他bean多少次，每次注入的都是同一个实例。 如果一个类是可变（mutable）的，那么对其进行重用时可能会遇到意想不到的问题。 Spring定义的bean作用域： 单例（Singleton）：在整个应用中，只创建一个bean； 原型（Prototype）：每次注入或者通过上下文获取bean时都创建一个新的bean； 会话（Session）：在Web应用中，为每个回话创建一个bean； 请求（Request）：在Web应用中，为每个请求创建一个bean。 @Scope注解： 用来指定bean的作用域： 123456@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//或者 @Scope("prototype")public class Notepad &#123; //something&#125; XML配置： 1&lt;bean id="notepad" class="com.app.Notepad" scope="prototype" /&gt; 3.5 运行时值注入Spring提供了两种运行时求值的方式： 属性占位符（Property placeholder）； Spring表达式语言（S片EL）。 1234567891011@Configuration@PropertySource("classpath:/com/soundsys/app.properties")public class ExpressiveConfig &#123; @Autowired Environment env; @Bean public BlankDisc disc() &#123; return new BlankDisc(env.getProperty("disc.title"), env.getProperty("disc.artist")); &#125;&#125; Spring的Environment： getProperty()方法的四种重载方式： String getProperty(String key)； String getProperty(String key, String defaultValue)； T getProperty(String key, Class type)； T getProperty(String key, Class type, T defaultValue)； 使用重载形式的getProperty()方法可以避免类型转换： 1int connectionCount = env.getProperty("db.connection.count", Integer.class, 10); Environment常见方法： boolean containsProperty(String property)； String[] getActiveProfiles()； String[] getDefaultProfiles()； boolean acceptsProfiles(String… profiles)。 解析属性占位符： Spring支持将属性定义到外部的属性文件中，并使用占位符将其值插入到Spring bean中。在Spring装配中，占位符的形式为使用 “${…}” 的形式包装的属性名称。 1&lt;bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="$&#123;disc.title&#125;" c:_artist="$&#123;disc.artist&#125;" /&gt; 使用组件扫描和自动装配时： 1234public BlankDisc(@Value("$&#123;disc.title&#125;" String title, @Value("$&#123;disc.artist&#125;") String artist) &#123; this.title = title; this.artist = artist;&#125; SpEL表达式语言： 将表达式语言放到 “#{…}” 之中。 “#{1 + 1}” “#{T(System).currentMillis()}” “#{sgtPeppers.artist}” “#{false}” “#{artistSelector.selectArtists().toUpperCase()}” SpEL运算符： 运算符类型 运算符 算术运算符 +、-、*、/、%、 比较运算符 &lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge 逻辑运算符 and、or、not、| 条件运算符 ?:(ternary)、?:() 正则表达式 matches 计算正则表达式： 1#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'&#125; 计算集合： 12345#&#123;jukebox.songs[4].title&#125;#&#123;jukebox.songs[T(java.lang.Math).random()*jukebox.songs.size()].title&#125;#&#123;jukebox.songs.?[artist eq 'Aerosmith']&#125; //.?[]得到集合的一个子集#&#123;jukebox.songs.^[artist eq 'Areosmith']&#125; //.^[]查询集合中的第一个匹配项#&#123;jukebox.songs.$[artist eq 'Areosmith'].![title]&#125; //.$[]查询集合中的最后一个匹配项，.![]从集合的每个成员中选择特定的属性放到另外一个集合中]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之Reverse Polish Notation]]></title>
    <url>%2F2018%2F11%2F24%2FLeetCode%E4%B9%8BReverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[1. 关于Reverse Polish Notation摘自 维基百科 的解释： 逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。 2. 题目内容Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are+,-,*,/. Each operand may be an integer or another expression.Some examples: [“2”, “1”, “+”, “3”, “*”] -&gt; ((2 + 1) * 3) -&gt; 9 [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6 3. 解题思路对于一个合法的字符数组，依次扫描该字符数组： 如果该字符是”+”,”-“,”*”,”/“中的任意一个，则将其放入栈中； 如果该字符是操作符，则从栈中取出两个操作数按照顺序进行运算； 直到扫描完毕，取出栈中的最后一个数，即为结果。 4. 代码实现123456789101112131415161718192021222324252627282930313233343536public int evalRPN(String[] tokens) &#123; List&lt;String&gt; operators = new ArrayList&lt;String&gt;() &#123;&#123; add("+"); add("-"); add("*"); add("/"); &#125;&#125;; Stack&lt;Integer&gt; tempValue = new Stack&lt;&gt;(); int number1; int number2; int result = 0; for (String token : tokens) &#123; if (!operators.contains(token)) &#123; tempValue.push((Integer.valueOf(token))); &#125; else &#123; number1 = tempValue.pop(); number2 = tempValue.pop(); switch (token) &#123; case "+": result = number2 + number1; break; case "-": result = number2 - number1; break; case "*": result = number2 * number1; break; case "/": result = number2 / number1; break; &#125; tempValue.push(result); &#125; &#125; return tempValue.pop();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python爬取B站数据]]></title>
    <url>%2F2018%2F11%2F22%2F%E5%88%A9%E7%94%A8Python%E7%88%AC%E5%8F%96B%E7%AB%99%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[最初的想法最近在睿站上看到B小将的很多睿智评论，于是想起能不能爬一下B站的用户信息，看看能不能统计一下B站的年龄信息。但是很遗憾，在个人主页里只能看到注册日期和生日，而不能看到完整的生日信息。 还是换个目标吧，好久没用python了，就当是复习一下基础知识。于是找了一下B站的API，官方没有开放的API可供调用，意料之中，已经有大佬准备好了：GitHub-B站野生接口 。 1234567891011class BilibiliSpider(object): def __init__(self): self.online_api = "https://api.bilibili.com/x/web-interface/online" # 在线人数 self.video_api = "https://api.bilibili.com/x/web-interface/archive/stat?&amp;aid=%s" # 视频信息 self.newlist_api = "https://api.bilibili.com/x/web-interface/newlist?&amp;rid=%s&amp;pn=%s&amp;ps=%s" # 最新视频信息 self.region_api = "https://api.bilibili.com/x/web-interface/dynamic/region?&amp;rid=%s&amp;pn=%s&amp;ps=%s" # 最新动态信息 self.member_api = "http://space.bilibili.com/ajax/member/GetInfo" # 用户信息 self.stat_api = "https://api.bilibili.com/x/relation/stat?vmid=%s" # 用户关注数和粉丝总数 self.upstat_api = "https://api.bilibili.com/x/space/upstat?mid=%s" # 用户总播放量和总阅读量 self.follower_api = "https://api.bilibili.com/x/relation/followings?vmid=%s&amp;pn=%s&amp;ps=%s" # 用户关注信息 self.fans_api = "https://api.bilibili.com/x/relation/followers?vmid=%s&amp;pn=%s&amp;ps=%s" # 用户粉丝信息 抓取在线人数最简单的例子，在 StuPeter 的例子里有现成的代码： 1234567def member_online_count(self): ret_val = requests.get(self.online_api) if ret_val.status_code != 200 or ret_val.content is None: print("获取当前在线人数失败") return None ret_content = json.loads(ret_val.content) return ret_content["data"]["web_online"] 将返回数据写入文件每次执行脚本都记录下当前时间： 12345def write_to_file(self, cnt): now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") f = open(self.file, "a") content_to_write = "[" + now + "] : [" + str(cnt) + "]" f.write(content_to_write + "\n") 配置定时任务配置定时任务(Ubantu18.04)每十分钟执行一次： 10,10,20,30,40,50 * * * * python /home/username/python/bilibili_spider.py matplotlib折线图展示爬完数据之后数据数据都在文件里，直接数据文件中读取记录下的 时间 和 人数值，做成折线图： 还需要再研究研究，to be updated…]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客同时部署到github和coding并设置双线解析]]></title>
    <url>%2F2018%2F11%2F19%2FHexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%92%8Ccoding%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%8F%8C%E7%BA%BF%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[起因因为github服务器禁止了百度爬虫，所以不能百度收录不了站点，导致访问量很低，本来不想折腾的，想了一下还是将博客也部署到了coding上，方便百度的收录。 实践 在coding上创建一个名为 用户名 (不是昵称)的项目，并开启pages服务； 将本地ssh公钥文件添加到coding的SSH公钥中并测试是否能访问： 1ssh -T -p 443 git@git-ssh.coding.net 在站点配置文件中添加上coding仓库地址： 123456deploy: type: git repository: github: git@github.com:Kotobuki-Tsumugi/Kotobuki-Tsumugi.github.io.git coding: git@git.dev.tencent.com:Kobobuki-Tsumugi/Kobobuki-Tsumugi.git branch: master 在站点目录/source下创建一个名为Staticfile的空文件； 生成并上传静态文件： 12hexo cleanhexo g -d 在域名解析中新增两条CNAME记录，指向username.coding.me，注意区分境外线路和默认线路，指向coding的必须为默认线路，如果不能正常访问，可以先暂停github的解析，待coding的解析成功后再开启github的解析，解析反应不及时。 向百度提交站点sitemap文件地址。 遇到的问题其中也遇到一些玄学的问题： 比如上图，我如果绑定youyou-2608.com 则一直提示“域名未联通”，即便我已经添加了指向username.coding.me的CNAME记录，添加www.youyou-2608.com 能绑定上，但是绑定状态一直是异常，访问username.coding.me也能正常跳转到https://youyou-2608.com ，没太搞明白，既然已经能正常访问，也就作罢了。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>Hexo博客维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客备份]]></title>
    <url>%2F2018%2F11%2F18%2FHexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[养成备份的好习惯花了好长时间总算是把博客搭建起来了，之前自己买的服务器用Wordpress搭建博客，但是因为服务器经常需要使用，安装一些其他软件什么的，导致Wordpress运行不是很稳定，还很容易被墙。 因为Hexo每次执行hexo g -d之后发布的都是生成的静态文件，站点以及主题的配置文件不会一同发布到github上，最重要的是，如果在另一个机器上要更新博客，根本做不到。所以就想着把源文件备份一下。 使用github备份轻松备份github本来就是一个仓库，用它来备份最合适不过了。 建立本地文件夹，将需要备份的文件存拷贝到该文件夹中； 在username.github.io仓库下新建一个分支； 建立本地备份文件夹与远程仓库的关联； 将本地文件夹push到仓库； 每次博客更新，先发布静态文件，然后在提交源文件。 需要备份的文件 _config.yml package.json /scaffolds /source /themes 问题感觉每次更新博客之后都需要拷贝一下上面这几个文件，感觉还是比较麻烦，没想到什么好办法。 git第一次commit之后才能查看到本地分支，push之后能显示远程分支。 更新用python脚本来复制文件，并且将执行命令添加到终端命令中，这样只需要多执行一个自定义命令来运行脚本，更方便。 123456789101112131415161718192021222324252627282930313233#!user/bin/env python# coding=utf-8import ossource_path = "/Users/youyou2608/Kotobuki"target_path = "/Users/youyou2608/BlogBack"filter_files = ["db.json", "public", "package-lock.json", "node_modules", ".deploy_git"]file_updated = []def copy_files(source_dir, target_dir): for f in os.listdir(source_dir): if f in filter_files: continue source_file = os.path.join(source_dir, f) target_file = os.path.join(target_dir, f) if os.path.isfile(source_file): if not os.path.exists(target_dir): os.makedirs(target_dir) if not os.path.exists(target_file) or ( os.path.exists(target_file) and os.path.getsize(target_file) != os.path.getsize(source_file)): open(target_file, "wb").write(open(source_file, "rb").read()) file_updated.append(source_file) if os.path.isdir(source_file): copy_files(source_file, target_file)if __name__ == "__main__": print("开始Hexo站点源文件复制..") copy_files(source_path, target_path) print("站点源文件复制完毕..") 在 /etc/profile 中添加一行：alias ‘copy_hexo_source’=’python copy_hexo_source.py’ ，这样终端运行 copy_hexo_source 就可以复制文件了。]]></content>
      <categories>
        <category>Exp</category>
      </categories>
      <tags>
        <tag>Hexo博客维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记-第二章-装配Bean]]></title>
    <url>%2F2018%2F11%2F17%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%A3%85%E9%85%8DBean%2F</url>
    <content type="text"><![CDATA[第二章：装配Bean 本章内容： 声明bean 构造器注入和Setter方法注入 装配bean 控制bean的创建和销毁 在Spring中，对象无需自己查找或创建与其所关联的对象，容器负责把需要相互协作的对象引用赋值给各个对象，这种协作关系成为装配。 2.1 Spring配置的可选方案 Spring容器负责创建应用程序中的bean并通过DI来协调对象之间的关系。开发人员需要做的是告诉Spring需要创建哪些对象并且如何装配在一起。 Spring提供了三种可选方式： XML配置 Java显式配置 隐式的bean发现机制和自动装配 如何选择：尽可能使用自动配置机制，当必须显式配置时使用JavaConfig，当JavaConfig中没有同样实现时使用XML配置。 2.2 自动化装配bean 自动扫描 自动装配 2.2.1 创建可被发现的bean123456789package com.kotobuki2.soundsys;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:21 */public interface CompactDisc &#123; void play();&#125; 123456789101112131415161718package com.kotobuki2.soundsys;import org.springframework.stereotype.Component;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:22 */@Componentpublic class SgtPeppers implements CompactDisc &#123; private String title = "SgtPeppers title"; private String artiest = "The Beatles"; @Override public void play() &#123; System.out.println("playing.."); &#125;&#125; 12345678910111213package com.kotobuki2.soundsys;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:24 */@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125; 通过XML配置开启注解扫描： 1&lt;context:component-scan base-package="soundsys"/&gt; 自动装配测试： 123456789101112131415161718192021222324252627package com.test;import com.kotobuki2.soundsys.CDPlayerConfig;import com.kotobuki2.soundsys.CompactDisc;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import static org.junit.Assert.assertNotNull;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午7:28 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)public class CDPlayerTest &#123; @Autowired private CompactDisc compactDisc; @Test public void cdTest() &#123; assertNotNull(compactDisc); &#125;&#125; 2.2.2 为组件扫描的bean命名默认将类名第一个字母小写后的字符串作为bean的id。 可以通过注解标示bean的别名： 1@Component("alias") 2.2.3 设置组件扫描的基础包默认以配置类所在的包为基础包进行扫描。 自定义扫描包： 1234@Configuration@ComponentScan("package-name")//扫描多个基础包@ComponentScan(basePackages = &#123;"package1", "package2"&#125;) 但是用直接指定包名会出现问题：包名被变更以后便无法扫描到所需要的类，因此，还有另一种指定扫描包的方法： 12@Configuration@ComponentScan(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;) 这种方式下，这些类所在的包都会作为基础包进行扫描，即便代码重构也不会受到影响。 2.2.4 通过为bean添加注解实现自动装配123456789package com.kotobuki2.soundsys;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午8:51 */public interface MediaPlayer &#123; void play();&#125; 1234567891011121314151617181920212223package com.kotobuki2.soundsys;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午8:50 */@Componentpublic class CDPlayer implements MediaPlayer &#123; private CompactDisc compactDisc; @Autowired public CDPlayer(CompactDisc compactDisc) &#123; this.compactDisc = compactDisc; &#125; @Override public void play() &#123; compactDisc.play(); &#125;&#125; @Autowired注解不仅能够用在构造器上，也能用在属性的Setter方法上。 2.3 通过Java装配bean 在进行显式配置的时候，JavaConfig是更好的方案，因为其强大、类型安全并且重构友好。因为其本身就是Java代码。 声明简单的bean： 1234@Bean(name="alias")public CompactDisc sgtPeppers() &#123; return new SgtPeppers();&#125; 借助JavaConfig实现注入： 123456789@Beanpublic CDPlayer cdPlayer()&#123; return CDPlayer(new sgtPeppers());&#125;@Beanpublic CDPlayer cdPlayer(CompactDisc disc)&#123; return new CDplayer(disc);&#125; 后者不要求disc必须在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者XML来进行配置。 通过构造器注入： 123456@Beanpublic CDPlayer cdPlayer(CompactDisc disc)&#123; CDPlayer cdPlayer = new CDPlayer(disc); cdPlayer.setCompactDisc(disc); return cdPlayer;&#125; 2.4 通过XML装配Bean在XML配置中，需要创建一个以作为根元素的XML配置文件。 可以借助Spring Tool Suite创建和管理Spring XML配置文件。 2.4.1 声明一个简单的bean：1&lt;bean id="bean_id" class="com.soundsys.SgtPeppers" /&gt; 如果没有指明id，bean将会根据类全限定名指定，为了减少XML配置的繁琐，只需要对需要按名称引用的bean进行命名。“com.soundsys.SgtPeppers#0”… 元素： 123&lt;bean id="cdPlayer" class="com.soundsys.CDPlayer"&gt; &lt;constructor-arg ref="compactDisc" /&gt;&lt;/bean&gt; 2.4.2 c命名空间p命名空间和c命名空间 2.4.3 将字面量注入到构造器中：1234&lt;bean id="compactDisc" class="com.soundsys.BlackDisc"&gt; &lt;constructor-arg value="title" /&gt; &lt;constructor-arg value="The Beatles" /&gt;&lt;/bean&gt; 使用 value 属性，将给定的值注入到构造器中。 2.4.3 装配集合12345678910&lt;bean id="beat" class="com.soundsys.beat"&gt; &lt;constructor-arg value="The Beatles"/&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;ref bean="bean1"/&gt; &lt;ref bean="bean2"/&gt; &lt;ref bean="bean3"/&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 或者 123456789&lt;bean id="beat" class="com.soundsys.beat"&gt; &lt;constructor-arg value="The Beatles"/&gt; &lt;constructor-arg&gt; &lt;set&gt; &lt;value&gt;SgtPeppers&lt;/value&gt; &lt;value&gt;The Beatles&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 使用两者的区别就是 list 和 set 会忽略重复元素。 2.4.4 p命名空间p命名空间和c命名空间 2.4.5 导入混合配置在 JavaConfig 中引用 JavaConfig 配置： 12345678@Configuration@Import(CDConfig.class)public class CDPlayerConfig &#123; @Bean public CDPlayer cdPlayer(CompactDisc disc) &#123; return new CDPlayer(disc); &#125;&#125; 或者： 1234@Configuration@Import(CDPlayerConfig.class, CDConfig.class)public class SoundSysConfig &#123;&#125; 新建一个配置类，使用@Import导入两个配置类。 在JavaConfig中引入XML配置： 12345@Configuration@Import(CDPlayerConfig.class)@ImportResource("classpath:cd-config.xml")public class SoundSysConfig &#123;&#125; 在XML配置中引用XML配置： 1234&lt;beans&gt; &lt;import resource="cd-config.xml"/&gt; &lt;bean id="cdPlayer" class="com.soundsys.CDPlayer" c:cd-ref="compactDisc"&gt;&lt;/beans&gt; 在XML中引入JavaConfig配置： 1234&lt;beans&gt; &lt;bean class="com.soundsys.CDConfig"/&gt; &lt;bean id="cdPlayer" class="com.soundsys.CDPlayer" c:cd-ref="compactDisc"/&gt;&lt;/beans&gt; 或者： 1234&lt;beans&gt; &lt;bean class="com.soundsys.CDConfig"/&gt; &lt;import resource="cdplayer-config.xml"/&gt;&lt;/beans&gt; 新建一个配置文件，分别导入JavaConfig配置和XML配置。 小结 Spring框架的核心是Spring容器，负责管理应用中组件的生命周期，它会创建这些组件并保证它们的依赖能够得到满足。 尽可能使用自动配置，以避免显式配置带来的维护成本。 如果确实需要显式配置，应优先选择基于Java的配置，因为其更加强大、类型安全且易于重构。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之单链表重排序]]></title>
    <url>%2F2018%2F11%2F17%2FLeetCode%E5%AD%90%E5%8D%95%E9%93%BE%E8%A1%A8%E9%87%8D%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[笑恨平生，不存欢愉。 问题描述Given a singly linked list L: L 0→L 1→…→L n-1→L n,reorder it to: L 0→L n →L 1→L n-1→L 2→L n-2→… You must do this in-place without altering the nodes’ values. For example,Given{1,2,3,4}, reorder it to{1,4,2,3}. 题目要求 时间限制：1秒 空间限制：32768K 解题思路两个游标：一个用来指向下一次将要插入元素的位置，另一个用来遍历链表。从根结点开始遍历，如果当前节点的next节点不为空并且next的next节点不为空，则取最后一个节点插入到当前节点之后，游标一跳两个位置。直到游标一节点的next节点为空或者next的next节点为空。 代码实现12345678910111213141516171819202122232425262728293031package com.reorder.list;import com.sort.linkedlist.ListNode;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午4:01 */public class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null) &#123; return; &#125; if (head.next == null || head.next.next == null) &#123; return; &#125; ListNode pt = head; ListNode index = head; ListNode preIndex = head; while (pt.next != null &amp;&amp; pt.next.next != null) &#123; while (index.next != null) &#123; preIndex = index; index = index.next; &#125; preIndex.next = null; index.next = pt.next; pt.next = index; pt = pt.next.next; &#125; &#125;&#125; 这种方法可行，但是每排序一个节点都需要遍历一次链表，效率比较低，可以看到下图，运行时间较长，占用内存已经 超过空间限制 了。 参考看了一下网上给出的方案，几乎都是一样的： 这道链表重排序问题可以拆分为以下三个小问题： 使用快慢指针来找到链表的中点，并将链表从中点处断开，形成两个独立的链表。 将第二个链翻转。 将第二个链表的元素间隔地插入第一个链表中。 都是将链表拆成两个独立的链表进行重排序。 剽窃来的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val;这道链表重排序问题可以拆分为以下三个小问题：1. 使用快慢指针来找到链表的中点，并将链表从中点处断开，形成两个独立的链表。2. 将第二个链翻转。3. 将第二个链表的元素间隔地插入第一个链表中。 * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode *head) &#123; if (!head || !head-&gt;next || !head-&gt;next-&gt;next) return; ListNode *fast = head; ListNode *slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode *mid = slow-&gt;next; slow-&gt;next = NULL; ListNode *last = mid; ListNode *pre = NULL; while (last) &#123; ListNode *next = last-&gt;next; last-&gt;next = pre; pre = last; last = next; &#125; while (head &amp;&amp; pre) &#123; ListNode *next = head-&gt;next; head-&gt;next = pre; pre = pre-&gt;next; head-&gt;next-&gt;next = next; head = next; &#125; &#125;&#125;; 时间空间使用都很少，性能问题没了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之二叉树非递归前序遍历]]></title>
    <url>%2F2018%2F11%2F17%2FLeetCode%E5%AD%90%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[问题描述：Given a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree{1,#,2,3}, 123451 \ 2 /3 return[1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 使用非递归的方法前序遍历二叉树。 问题分析前序遍历就是按照中、左、右的顺序对二叉树进行遍历。 思路很简单，如果当前节点不为空，不断遍历当前节点的左子树，如果当前节点有右子树的话，将其放入栈中以便后期遍历其右子树，如果当前节点为空，则取出栈顶元素按照同样的方式遍历其右子树。 代码实现12345678910111213141516171819202122232425262728293031package com.postorder.raversal;import java.util.ArrayList;import java.util.Stack;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午3:16 */public class PreOrderSolution &#123; public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pointer = root; while (pointer != null || !stack.isEmpty()) &#123; while (pointer != null) &#123; list.add(pointer.val); if (pointer.right != null) &#123; stack.push(pointer); &#125; pointer = pointer.left; &#125; if (stack.isEmpty()) &#123; break; &#125; pointer = stack.pop(); pointer = pointer.right; &#125; return list; &#125;&#125; 牛客网做得还不错，就是现在还是只支持C++和Java。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之二叉树非递归后续遍历]]></title>
    <url>%2F2018%2F11%2F17%2FLeetCode%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[周末突然降温，哪儿也去不了，不如在家刷题。 题目描述Given a binary tree, return the postorder traversal of its nodes’ values. For example:Given binary tree{1,#,2,3}, 123451 \ 2 /3 return[3,2,1]. Note: Recursive solution is trivial, could you do it iteratively？ 使用非递归方法后序遍历二叉树。 解题思路二叉树后序遍历就是对每个节点按照左、右、中的顺序进行遍历。 详细的解析参见：二叉树遍历(先序、中序、后序) ，讲得非常详细易懂。 代码实现123456789101112131415161718192021222324252627282930313233package com.postorder.raversal;import java.util.ArrayList;import java.util.Stack;/** * @author zhulongkun20@163.com * @since 2018/11/17 下午1:49 */public class Solution &#123; public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode pointer = root; TreeNode lastVisit = root; while (!stack.isEmpty() || pointer != null) &#123; while (pointer != null) &#123; stack.push(pointer); pointer = pointer.left; &#125; pointer = stack.peek(); if (pointer.right == null || pointer.right == lastVisit) &#123; list.add(pointer.val); lastVisit = pointer; stack.pop(); pointer = null; &#125; else &#123; pointer = pointer.right; &#125; &#125; return list; &#125;&#125; 是时候好好重修一下数据结构了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之链表插入排序]]></title>
    <url>%2F2018%2F11%2F16%2FLeetCode%E4%B9%8B%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[链表插入排序 是 牛客网 上LeetCode在线编程的一道题。 题目描述Sort a linked list using insertion sort. 使用插入排序对链表排序，此处为单链表。 解题思路插入排序就是依次将未排序部分的第一个元素插入到已排序部分合适的位置，使得已排序部分仍然有序。 列表可以直接根据位置索引元素，但是链表不可以直接取得指定位置的元素。 根据插入排序的思路：将整个链表按照已排序和未排序分为两部分，未排序部分的首个元素即为将要被排序的元素，问题变为将一个元素插入到一个有序链表中使得该链表仍然有序。分为两种情况：一种是合适位置在有序链表的非末尾，另一种是在有序链表的末尾，然后其他的问题就是注意插入时的赋值顺序。 代码实现 12345678910111213141516171819public ListNode insertionSortList1(ListNode head) &#123; ListNode root = new ListNode(-1); while (head != null) &#123; ListNode temp = root; while (temp.next != null &amp;&amp; head.val &gt;= temp.next.val) temp = temp.next; if (temp.next == null) &#123; temp.next = head; head = head.next; temp.next.next = null; &#125; else &#123; ListNode temp2 = temp.next; temp.next = head; head = head.next; temp.next.next = temp2; &#125; &#125; return root.next;&#125; 参考：http://www.cnblogs.com/tonyluis/p/4579295.html 最近将博客从WordPress搬到了GitHub，WordPress比较灵活，但是价格昂贵的服务器是为此付出的代价。后来看到 简书 页面比较简洁，尝试了一下简书，MarkDown编辑器有实时预览，比博客园那不知道要高到哪里去了， 博客园 从16年就在开发的MarkDown编辑器，快2019年了还没投入使用。用了两周简书发现简书的阅读量几乎为0。还尝试了 掘金、SegmentFault 最近考虑博客搬迁才知道还有 Hexo 存在，于是喜出望外的转移了平台，花了点时间配置了 Next 主题以及域名之类的，GitHub 真的良心，不得不让我再恶心一下吃相难看想钱想疯的 CSDN。 博客地址：https://kotobuki-tsumugi.github.io，https://youyou-2608.com，欢迎访问。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记-第一章-Spring之旅]]></title>
    <url>%2F2018%2F11%2F14%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[第一部分：Spring的核心 第一章：Spring之旅 介绍Spring框架，包括Spring DI和AOP。 第二章：装配Bean Spring的自动配置、基于Java的配置和XML配置。 第三章：高级装配 Spring的条件化配置，处理自动装配时的歧义性，作用域以及Spring表达式语言。 第四章：面向切面的Spring 展示如何使用Spring的AOP特性把系统级服务从它们所服务的对象中解耦出来。 第一章 Spring之旅 本章内容： Spring的Bean容器 介绍Spring的核心模块 更为强大的Spring生态系统 Spring的新功能 创建Spring的主要目的是用来替代更加重量级的企业级Java技术，尤其是EJB。相当于EJB来说，Spring提供了更加轻量级和更加简单的编程模型。 1.1 简化Java开发1.1.1 Spring的非侵入式编程在基于Spring构建的应用中，一般不会有任何痕迹表明你使用了Spring，最坏的场景是在一个类上使用了Spring注解，但是这个类依旧是一个Pojo类。 Spring的非侵入式编程模型意味着这个类在Spring应用还是在非Spring应用中都能发挥同样的作用。 1234567891011package com.kotobuki;/** * @author zhulongkun20@163.com * @since 2018/11/14 下午9:18 */public class HelloWorld &#123; public String sayHello() &#123; return "Hello world"; &#125;&#125; 1.1.2 依赖注入在一个应用中通常会涉及到很多类，这些类需要相互协作来完成特定的功能，如果让每个类管理与自己协作的类，则会导致应用高度耦合。 依赖注入带来的最大好处就是松耦合。如果一个对象只通过借口来表明依赖关系，那么这种依赖就能够在对象毫不知情的情况下用不同的实现替换。 可以让对其他的类有依赖的类自动获得已经准备好的依赖。 一个送外卖的过程：当不是用DI的时候送餐员需要自己准备外卖，然后再配送。 1234567891011121314151617181920package com.clerk;import com.com.food.Dinner;/** * @author zhulongkun20@163.com * @since 2018/11/15 下午8:31 */public class DeliveryWithoutDI implements Delivery &#123; private Dinner dinner; public DeliveryWithoutDI() &#123; this.dinner = new Dinner("rice"); &#125; @Override public void delivery() &#123; System.out.println("delivery it on time."); &#125;&#125; 当使用DI之后，当有外卖需要配送的时候，分配送餐员，送餐员会自动获得需要配送的外卖，需要做的只是负责配送，而不用关心其他事情。 1234567891011121314151617181920package com.clerk;import com.com.food.Dinner;/** * @author zhulongkun20@163.com * @since 2018/11/15 下午8:24 */public class DeliveryClerk implements Delivery &#123; private Dinner dinner; public DeliveryClerk(Dinner dinner) &#123; this.dinner = dinner; &#125; @Override public void delivery() &#123; System.out.println("delivery on time."); &#125;&#125; 1.1.3 应用切面 面向切面编程允许你把遍布应用各处的功能分离出来形成可重用的组件。 一个系统或应用由许多不同的组件构成，但是每一个组件在负责自己的功能之外，通常还要承担额外的责任。一些与核心业务无关的代码会融入到核心业务逻辑中。比如转账，除了发生金钱的转移之外，还要验证身份、记录账单以及给用户发送通知。这些会跨越系统的组件成为横切关注点。它们会使核心业务代码变得复杂。 通过AOP，可以将与核心业务无关的代码分离出来。 1.1.4 使用模板消除样板式代码使用JDBC访问数据库，会产生大量与查询语句无关的代码，还必须要捕捉异常，虽然无济于事。 Spring旨在通过模板封装来消除样板式代码。 Data Access with JDBC 1.2 容纳你的bean 在Spring应用中，你的应用对象生存于Spring容器中，Spring容器负责创建对象，装配并管理它们的整个生命周期。 使用应用上下文： AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。 AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载Spring Web应用上下文。 ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义。 FileSystemXmlApplicationContext：从文件系统下的一个或多个XML配置文件中加载上下文定义。 XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中还在上下文定义。 bean的生命周期： 1.3 俯瞰Spring风景线Spring的模块： Core IoC container, Events, Resources, i18n, Validation, Data Binding, Type Conversion, SpEL, AOP. Testing Mock objects, TestContext framework, Spring MVC Test, WebTestClient. Data Access Transactions, DAO support, JDBC, ORM, Marshalling XML. Web Servlet Spring MVC, WebSocket, SockJS, STOMP messaging. Web Reactive Spring WebFlux, WebClient, WebSocket. Integration Remoting, JMS, JCA, JMX, Email, Tasks, Scheduling, Cache. Languages Kotlin, Groovy, Dynamic languages.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode之水仙花数]]></title>
    <url>%2F2018%2F11%2F11%2FLeetCode%E4%B9%8B%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1. 水仙花数以下是摘自 维基百科 中的释义： 在数论中，水仙花数（Narcissistic number）[1][2]，也被称为超完全数字不变数（pluperfect digital invariant, PPDI）[3]/sup&gt;、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number）[4] ，用来描述一个N位非负整数，其各位数字的N次方和等于该数本身。 这里定义的N=3。 2. 问题描述春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的： “水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=1^3+5^3+3^3。 现在要求输出所有在m和n范围内的水仙花数。 对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;如果给定的范围内不存在水仙花数，则输出no;每个测试实例的输出占一行。 输入：100 120300 380 输出：no370 371 3. 问题分析我的解决思路：先将给出的数字按照个位十位百位的顺序拆解，然后计算各数位三次方之和，再和原数进行比较比较。思路比较简单。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.odd.number;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/** * @author zhulongkun20@163.com * @since 2018/11/3 下午12:58 */public class Solution &#123; private static List&lt;Integer&gt; getNumbers(int start, int end) &#123; List&lt;Integer&gt; comps = new ArrayList&lt;&gt;(); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); double num; for (int i = start; i &lt;= end; i++) &#123; num = 0; comps.clear(); comps = getNumberComponent(i); for (Integer comp : comps) &#123; num += Math.pow(comp, 3); &#125; if (num == i) &#123; result.add(i); &#125; &#125; return result; &#125; private static List&lt;Integer&gt; getNumberComponent(int number) &#123; int base = 10; int comp; int lastComp; List&lt;Integer&gt; components = new ArrayList&lt;&gt;(); while (number % (base / 10) != number) &#123; int power = 0; lastComp = 0; for (Integer index : components) &#123; lastComp += index * Math.pow(10, power); power += 1; &#125; comp = ((number - lastComp) % base) / (base / 10); components.add(comp); base *= 10; &#125; return components; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; result; Scanner input = new Scanner(System.in); while (input.hasNextLine()) &#123; String str = input.nextLine(); String[] numbers = str.split(" "); for (int i = 0; i &lt; numbers.length - 1; i++) &#123; int start = Integer.valueOf(numbers[i]); int end = Integer.valueOf(numbers[i + 1]); result = getNumbers(start, end); if (result.isEmpty()) &#123; System.out.println("no"); &#125; else &#123; for (Integer aResult : result) &#123; System.out.print(aResult + " "); &#125; System.out.println(); &#125; &#125; &#125; &#125;&#125; 他山之石貌似在评论区里看到了有用python解决的： 没太看懂。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
